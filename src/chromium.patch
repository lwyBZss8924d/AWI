diff --git a/carbonyl/build b/carbonyl/build
new file mode 120000
index 0000000000000..44735d5866459
--- /dev/null
+++ b/carbonyl/build
@@ -0,0 +1 @@
+../../../build
\ No newline at end of file
diff --git a/carbonyl/src b/carbonyl/src
new file mode 120000
index 0000000000000..dabb0e15a991e
--- /dev/null
+++ b/carbonyl/src
@@ -0,0 +1 @@
+../../../src
\ No newline at end of file
diff --git a/cc/paint/display_item_list.cc b/cc/paint/display_item_list.cc
index 83fa63fd38eb4..31b32415d900a 100644
--- a/cc/paint/display_item_list.cc
+++ b/cc/paint/display_item_list.cc
@@ -103,7 +103,7 @@ void DisplayItemList::CaptureContent(const gfx::Rect& rect,
         if (!content->empty() && content->back().node_id == op.node_id)
           content->back().visual_rect.Union(rect);
         else
-          content->emplace_back(op.node_id, rect);
+          content->emplace_back(op.node_id, rect, op.flags.getColor4f());
       });
 }
 
diff --git a/cc/paint/node_id.h b/cc/paint/node_id.h
index 7b107630f17b7..0b27fa070b4ae 100644
--- a/cc/paint/node_id.h
+++ b/cc/paint/node_id.h
@@ -7,6 +7,7 @@
 
 #include "cc/paint/paint_export.h"
 #include "ui/gfx/geometry/rect.h"
+#include "third_party/skia/include/core/SkColor.h"
 
 namespace cc {
 // The NodeId is used to associate the DOM node with PaintOp, its peer in
@@ -21,11 +22,12 @@ using NodeId = int;
 static const NodeId kInvalidNodeId = 0;
 
 struct CC_PAINT_EXPORT NodeInfo {
-  NodeInfo(NodeId node_id, const gfx::Rect& visual_rect)
-      : node_id(node_id), visual_rect(visual_rect) {}
+  NodeInfo(NodeId node_id, const gfx::Rect& visual_rect, SkColor4f color = SkColors::kTransparent)
+      : node_id(node_id), visual_rect(visual_rect), color(color) {}
 
   NodeId node_id;
   gfx::Rect visual_rect;
+  SkColor4f color;
 };
 
 }  // namespace cc
diff --git a/cc/trees/layer_tree_host.cc b/cc/trees/layer_tree_host.cc
index 55295cc3f1e2f..466ba3380d93f 100644
--- a/cc/trees/layer_tree_host.cc
+++ b/cc/trees/layer_tree_host.cc
@@ -481,6 +481,49 @@ bool LayerTreeHost::MainFrameUpdatesAreDeferred() const {
 bool LayerTreeHost::IsUsingLayerLists() const {
   return settings_.use_layer_lists;
 }
+ 
+void LayerTreeHost::StartTerminalRender() {
+  DCHECK(IsMainThread());
+
+  // Wait until pending renders are done
+  if (terminal_render_pending_) {
+    return;
+  }
+
+  if (needs_terminal_render_) {
+    needs_terminal_render_ = false;
+  } else {
+    return;
+  }
+
+  auto it = terminal_render_callbacks_.begin();
+
+  while (it != terminal_render_callbacks_.end()) {
+    auto& callback = *it->get();
+
+    if (callback) {
+      callback();
+
+      it++;
+    } else {
+      it = terminal_render_callbacks_.erase(it);
+    }
+  }
+}
+
+void LayerTreeHost::ScheduleTerminalRender() {
+  task_runner_provider_->MainThreadTaskRunner()->PostTask(
+    FROM_HERE,
+    BindOnce(&LayerTreeHost::StartTerminalRender, weak_factory_.GetWeakPtr())
+  );
+}
+
+void LayerTreeHost::BeginTerminalRender(std::vector<gfx::Transform> transforms) {
+  // needs_terminal_render_ = true;
+  // terminal_render_transforms_ = std::move(transforms);
+
+  // ScheduleTerminalRender();
+}
 
 void LayerTreeHost::CommitComplete(const CommitTimestamps& commit_timestamps) {
   DCHECK(IsMainThread());
@@ -1648,6 +1691,12 @@ bool LayerTreeHost::PaintContent(const LayerList& update_layer_list) {
   for (const auto& layer : update_layer_list) {
     did_paint_content |= layer->Update();
   }
+
+  // if (did_paint_content) {
+    needs_terminal_render_ = true;
+    StartTerminalRender();
+  // }
+
   return did_paint_content;
 }
 
diff --git a/cc/trees/layer_tree_host.h b/cc/trees/layer_tree_host.h
index c26301594abc2..63c47fe511454 100644
--- a/cc/trees/layer_tree_host.h
+++ b/cc/trees/layer_tree_host.h
@@ -167,6 +167,21 @@ class CC_EXPORT LayerTreeHost : public MutatorHostClient {
   // Returns the process global unique identifier for this LayerTreeHost.
   int GetId() const;
 
+  // Carbonyl
+  void StartTerminalRender();
+  void ScheduleTerminalRender();
+  const std::vector<gfx::Transform>& GetTerminalRenderTransforms() {
+    return terminal_render_transforms_;
+  }
+  void SetTerminalRenderPending(bool pending) {
+    terminal_render_pending_ = pending;
+
+    ScheduleTerminalRender();
+  }
+  void ObserveTerminalRender(std::shared_ptr<std::function<bool()>> callback) {
+    terminal_render_callbacks_.push_back(callback);
+  }
+
   // The commit state for the frame being assembled by the compositor host.
   const CommitState* pending_commit_state() const {
     DCHECK(IsMainThread());
@@ -713,6 +728,7 @@ class CC_EXPORT LayerTreeHost : public MutatorHostClient {
   LayerListReverseConstIterator rend() const;
 
   // LayerTreeHost interface to Proxy.
+  void BeginTerminalRender(std::vector<gfx::Transform> transforms);
   void WillBeginMainFrame();
   void DidBeginMainFrame();
   void BeginMainFrame(const viz::BeginFrameArgs& args);
@@ -1086,6 +1102,13 @@ class CC_EXPORT LayerTreeHost : public MutatorHostClient {
 
   bool syncing_deltas_for_test_ = false;
 
+  // Carbonyl
+  bool needs_terminal_render_ = false;
+  bool terminal_render_pending_ = false;
+  std::vector<gfx::Transform> terminal_render_transforms_;
+  std::vector<std::shared_ptr<std::function<bool()>>> terminal_render_callbacks_;
+  base::WeakPtrFactory<LayerTreeHost> weak_factory_{this};
+
   base::WeakPtrFactory<LayerTreeHost> weak_ptr_factory_{this};
 };
 
diff --git a/cc/trees/layer_tree_host_impl.cc b/cc/trees/layer_tree_host_impl.cc
index 45b74d16e038a..9710021e36c1a 100644
--- a/cc/trees/layer_tree_host_impl.cc
+++ b/cc/trees/layer_tree_host_impl.cc
@@ -1463,6 +1463,8 @@ DrawResult LayerTreeHostImpl::CalculateRenderPasses(FrameData* frame) {
         append_quads_data.has_shared_element_resources;
   }
 
+  // client_->SetVideoNeedsBeginFrames(frame->may_contain_video);
+
   if (GetActivelyScrollingType() != ActivelyScrollingType::kNone &&
       checkerboarded_no_recording_content_area > 0) {
     SetCurrentScrollCheckerboardsDueToNoRecording();
@@ -3048,6 +3050,15 @@ void LayerTreeHostImpl::DidFinishImplFrame(const viz::BeginFrameArgs& args) {
   frame_trackers_.NotifyFrameEnd(current_begin_frame_tracker_.Current(), args);
   impl_thread_phase_ = ImplThreadPhase::IDLE;
   current_begin_frame_tracker_.Finish();
+
+  // Collect the layer transformation
+  std::vector<gfx::Transform> transforms;
+
+  for (const auto* layer : *active_tree()) {
+    transforms.push_back(layer->ScreenSpaceTransform());
+  }
+
+  client_->BeginTerminalRender(std::move(transforms));
 }
 
 void LayerTreeHostImpl::DidNotProduceFrame(const viz::BeginFrameAck& ack,
diff --git a/cc/trees/layer_tree_host_impl.h b/cc/trees/layer_tree_host_impl.h
index 568c240385296..99e32d890230f 100644
--- a/cc/trees/layer_tree_host_impl.h
+++ b/cc/trees/layer_tree_host_impl.h
@@ -113,6 +113,8 @@ enum class GpuRasterizationStatus {
 // LayerTreeHost->Proxy callback interface.
 class LayerTreeHostImplClient {
  public:
+  virtual void BeginTerminalRender(std::vector<gfx::Transform> transforms) = 0;
+
   virtual void DidLoseLayerTreeFrameSinkOnImplThread() = 0;
   virtual void SetBeginFrameSource(viz::BeginFrameSource* source) = 0;
   virtual void DidReceiveCompositorFrameAckOnImplThread() = 0;
diff --git a/cc/trees/proxy_impl.cc b/cc/trees/proxy_impl.cc
index 4cc820fd9393d..5f5d51e3bf74c 100644
--- a/cc/trees/proxy_impl.cc
+++ b/cc/trees/proxy_impl.cc
@@ -421,6 +421,14 @@ void ProxyImpl::SetBeginFrameSource(viz::BeginFrameSource* source) {
   }
 }
 
+void ProxyImpl::BeginTerminalRender(std::vector<gfx::Transform> transforms) {
+  DCHECK(IsImplThread());
+  MainThreadTaskRunner()->PostTask(
+      FROM_HERE, base::BindOnce(&ProxyMain::BeginTerminalRender,
+                                proxy_main_weak_ptr_,
+                                std::move(transforms)));
+}
+
 void ProxyImpl::DidReceiveCompositorFrameAckOnImplThread() {
   TRACE_EVENT0("cc,benchmark",
                "ProxyImpl::DidReceiveCompositorFrameAckOnImplThread");
diff --git a/cc/trees/proxy_impl.h b/cc/trees/proxy_impl.h
index f642fc41072c8..062680ac48320 100644
--- a/cc/trees/proxy_impl.h
+++ b/cc/trees/proxy_impl.h
@@ -95,6 +95,7 @@ class CC_EXPORT ProxyImpl : public LayerTreeHostImplClient,
   // LayerTreeHostImplClient implementation
   void DidLoseLayerTreeFrameSinkOnImplThread() override;
   void SetBeginFrameSource(viz::BeginFrameSource* source) override;
+  void BeginTerminalRender(std::vector<gfx::Transform> transforms) override;
   void DidReceiveCompositorFrameAckOnImplThread() override;
   void OnCanDrawStateChanged(bool can_draw) override;
   void NotifyReadyToActivate() override;
diff --git a/cc/trees/proxy_main.cc b/cc/trees/proxy_main.cc
index 69d38e76fc848..f9dcc3e76fe59 100644
--- a/cc/trees/proxy_main.cc
+++ b/cc/trees/proxy_main.cc
@@ -126,6 +126,11 @@ void ProxyMain::DidCompletePageScaleAnimation() {
   layer_tree_host_->DidCompletePageScaleAnimation();
 }
 
+void ProxyMain::BeginTerminalRender(std::vector<gfx::Transform> transforms) {
+  DCHECK(IsMainThread());
+  layer_tree_host_->BeginTerminalRender(std::move(transforms));
+}
+
 void ProxyMain::BeginMainFrame(
     std::unique_ptr<BeginMainFrameAndCommitState> begin_main_frame_state) {
   DCHECK(IsMainThread());
diff --git a/cc/trees/proxy_main.h b/cc/trees/proxy_main.h
index 66f2ac623022c..dc5d3545a1ebd 100644
--- a/cc/trees/proxy_main.h
+++ b/cc/trees/proxy_main.h
@@ -61,6 +61,7 @@ class CC_EXPORT ProxyMain : public Proxy {
   void RequestNewLayerTreeFrameSink();
   void DidInitializeLayerTreeFrameSink(bool success);
   void DidCompletePageScaleAnimation();
+  void BeginTerminalRender(std::vector<gfx::Transform> transforms);
   void BeginMainFrame(
       std::unique_ptr<BeginMainFrameAndCommitState> begin_main_frame_state);
   void DidCompleteCommit(CommitTimestamps);
diff --git a/cc/trees/single_thread_proxy.cc b/cc/trees/single_thread_proxy.cc
index e5957253734f6..12fc1d0b1509a 100644
--- a/cc/trees/single_thread_proxy.cc
+++ b/cc/trees/single_thread_proxy.cc
@@ -603,6 +603,13 @@ void SingleThreadProxy::SetBeginFrameSource(viz::BeginFrameSource* source) {
     scheduler_on_impl_thread_->SetBeginFrameSource(source);
 }
 
+void SingleThreadProxy::BeginTerminalRender(std::vector<gfx::Transform> transforms) {
+  DCHECK(!task_runner_provider_->HasImplThread() ||
+         task_runner_provider_->IsImplThread());
+
+  layer_tree_host_->BeginTerminalRender(std::move(transforms));
+}
+
 void SingleThreadProxy::DidReceiveCompositorFrameAckOnImplThread() {
   DCHECK(!task_runner_provider_->HasImplThread() ||
          task_runner_provider_->IsImplThread());
diff --git a/cc/trees/single_thread_proxy.h b/cc/trees/single_thread_proxy.h
index d6575b654c904..edee48ffcbbec 100644
--- a/cc/trees/single_thread_proxy.h
+++ b/cc/trees/single_thread_proxy.h
@@ -110,6 +110,7 @@ class CC_EXPORT SingleThreadProxy : public Proxy,
   // LayerTreeHostImplClient implementation
   void DidLoseLayerTreeFrameSinkOnImplThread() override;
   void SetBeginFrameSource(viz::BeginFrameSource* source) override;
+  void BeginTerminalRender(std::vector<gfx::Transform> transforms) override;
   void DidReceiveCompositorFrameAckOnImplThread() override;
   void OnCanDrawStateChanged(bool can_draw) override;
   void NotifyReadyToActivate() override;
diff --git a/components/content_capture/common/content_capture_features.cc b/components/content_capture/common/content_capture_features.cc
index 1c80d889e4f48..3cc1e77ea1a3f 100644
--- a/components/content_capture/common/content_capture_features.cc
+++ b/components/content_capture/common/content_capture_features.cc
@@ -34,15 +34,15 @@ BASE_FEATURE(kContentCaptureInWebLayer,
              base::FEATURE_ENABLED_BY_DEFAULT);
 
 bool IsContentCaptureEnabled() {
-  return base::FeatureList::IsEnabled(kContentCapture);
+  return true;
 }
 
 bool ShouldTriggerContentCaptureForExperiment() {
-  return base::FeatureList::IsEnabled(kContentCaptureTriggeringForExperiment);
+  return true;
 }
 
 bool IsContentCaptureEnabledInWebLayer() {
-  return base::FeatureList::IsEnabled(kContentCaptureInWebLayer);
+  return true;
 }
 
 int TaskInitialDelayInMilliseconds() {
diff --git a/components/viz/host/host_display_client.cc b/components/viz/host/host_display_client.cc
index 6d905b62e6258..bfb803829c73b 100644
--- a/components/viz/host/host_display_client.cc
+++ b/components/viz/host/host_display_client.cc
@@ -47,9 +47,9 @@ void HostDisplayClient::OnDisplayReceivedCALayerParams(
 }
 #endif
 
-#if BUILDFLAG(IS_WIN)
 void HostDisplayClient::CreateLayeredWindowUpdater(
     mojo::PendingReceiver<mojom::LayeredWindowUpdater> receiver) {
+#if BUILDFLAG(IS_WIN)
   if (!NeedsToUseLayerWindow(widget_)) {
     DLOG(ERROR) << "HWND shouldn't be using a layered window";
     return;
@@ -57,7 +57,9 @@ void HostDisplayClient::CreateLayeredWindowUpdater(
 
   layered_window_updater_ =
       std::make_unique<LayeredWindowUpdaterImpl>(widget_, std::move(receiver));
+#endif
 }
+#if BUILDFLAG(IS_WIN)
 void HostDisplayClient::AddChildWindowToBrowser(
     gpu::SurfaceHandle child_window) {
   NOTREACHED();
diff --git a/components/viz/host/host_display_client.h b/components/viz/host/host_display_client.h
index 5eeaadec9773f..f3409f0eeda03 100644
--- a/components/viz/host/host_display_client.h
+++ b/components/viz/host/host_display_client.h
@@ -47,11 +47,13 @@ class VIZ_HOST_EXPORT HostDisplayClient : public mojom::DisplayClient {
 #endif
 
 #if BUILDFLAG(IS_WIN)
-  void CreateLayeredWindowUpdater(
-      mojo::PendingReceiver<mojom::LayeredWindowUpdater> receiver) override;
   void AddChildWindowToBrowser(gpu::SurfaceHandle child_window) override;
 #endif
 
+  protected:
+  void CreateLayeredWindowUpdater(
+      mojo::PendingReceiver<mojom::LayeredWindowUpdater> receiver) override;
+
 // TODO(crbug.com/1052397): Revisit the macro expression once build flag switch
 // of lacros-chrome is complete.
 #if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS_LACROS)
diff --git a/components/viz/host/layered_window_updater_impl.cc b/components/viz/host/layered_window_updater_impl.cc
index 271486b45dcc8..a62210d8ca3c8 100644
--- a/components/viz/host/layered_window_updater_impl.cc
+++ b/components/viz/host/layered_window_updater_impl.cc
@@ -44,7 +44,7 @@ void LayeredWindowUpdaterImpl::OnAllocatedSharedMemory(
   // |region|'s handle will close when it goes out of scope.
 }
 
-void LayeredWindowUpdaterImpl::Draw(DrawCallback draw_callback) {
+void LayeredWindowUpdaterImpl::Draw(const gfx::Rect& damage_rect, DrawCallback draw_callback) {
   TRACE_EVENT0("viz", "LayeredWindowUpdaterImpl::Draw");
 
   if (!canvas_) {
diff --git a/components/viz/host/layered_window_updater_impl.h b/components/viz/host/layered_window_updater_impl.h
index 8af69cac78b74..9f74e511c263d 100644
--- a/components/viz/host/layered_window_updater_impl.h
+++ b/components/viz/host/layered_window_updater_impl.h
@@ -38,7 +38,7 @@ class VIZ_HOST_EXPORT LayeredWindowUpdaterImpl
   // mojom::LayeredWindowUpdater implementation.
   void OnAllocatedSharedMemory(const gfx::Size& pixel_size,
                                base::UnsafeSharedMemoryRegion region) override;
-  void Draw(DrawCallback draw_callback) override;
+  void Draw(const gfx::Rect& damage_rect, DrawCallback draw_callback) override;
 
  private:
   const HWND hwnd_;
diff --git a/components/viz/service/BUILD.gn b/components/viz/service/BUILD.gn
index fb793e98d5939..fdcddb36c4a09 100644
--- a/components/viz/service/BUILD.gn
+++ b/components/viz/service/BUILD.gn
@@ -16,6 +16,8 @@ config("viz_service_implementation") {
 
 viz_component("service") {
   sources = [
+    "../../../carbonyl/src/browser/software_output_device_proxy.cc",
+    "../../../carbonyl/src/browser/software_output_device_proxy.h",
     "debugger/rwlock.cc",
     "debugger/rwlock.h",
     "debugger/viz_debugger.cc",
diff --git a/components/viz/service/display_embedder/output_surface_provider_impl.cc b/components/viz/service/display_embedder/output_surface_provider_impl.cc
index d8f25c1435d4b..2929ebd3887c2 100644
--- a/components/viz/service/display_embedder/output_surface_provider_impl.cc
+++ b/components/viz/service/display_embedder/output_surface_provider_impl.cc
@@ -16,6 +16,7 @@
 #include "build/build_config.h"
 #include "build/chromecast_buildflags.h"
 #include "build/chromeos_buildflags.h"
+#include "carbonyl/src/browser/software_output_device_proxy.h"
 #include "cc/base/switches.h"
 #include "components/viz/common/display/renderer_settings.h"
 #include "components/viz/common/frame_sinks/begin_frame_source.h"
@@ -29,6 +30,7 @@
 #include "gpu/command_buffer/service/scheduler_sequence.h"
 #include "gpu/config/gpu_finch_features.h"
 #include "gpu/ipc/common/surface_handle.h"
+#include "services/viz/privileged/mojom/compositing/layered_window_updater.mojom.h"
 #include "ui/base/ui_base_switches.h"
 
 #if BUILDFLAG(IS_WIN)
@@ -134,10 +136,24 @@ std::unique_ptr<OutputSurface> OutputSurfaceProviderImpl::CreateOutputSurface(
   }
 }
 
+namespace {
+  static const bool use_layered_window = true;
+}
+
 std::unique_ptr<SoftwareOutputDevice>
 OutputSurfaceProviderImpl::CreateSoftwareOutputDeviceForPlatform(
     gpu::SurfaceHandle surface_handle,
     mojom::DisplayClient* display_client) {
+// #if !BUILDFLAG(IS_APPLE)
+  if (use_layered_window) {
+    DCHECK(display_client);
+    mojo::PendingRemote<mojom::LayeredWindowUpdater> layered_window_updater;
+    display_client->CreateLayeredWindowUpdater(
+        layered_window_updater.InitWithNewPipeAndPassReceiver());
+    return std::make_unique<SoftwareOutputDeviceProxy>(
+        std::move(layered_window_updater));
+  }
+// #endif
   if (headless_)
     return std::make_unique<SoftwareOutputDevice>();
 
diff --git a/components/viz/service/display_embedder/software_output_device_mac.cc b/components/viz/service/display_embedder/software_output_device_mac.cc
index c04eb117a5ec8..fcfcea5ddd285 100644
--- a/components/viz/service/display_embedder/software_output_device_mac.cc
+++ b/components/viz/service/display_embedder/software_output_device_mac.cc
@@ -105,6 +105,8 @@ void SoftwareOutputDeviceMac::UpdateAndCopyBufferDamage(
 
 SkCanvas* SoftwareOutputDeviceMac::BeginPaint(
     const gfx::Rect& new_damage_rect) {
+  last_damage = new_damage_rect;
+
   // Record the previous paint buffer.
   Buffer* previous_paint_buffer =
       buffer_queue_.empty() ? nullptr : buffer_queue_.back().get();
@@ -190,6 +192,7 @@ void SoftwareOutputDeviceMac::EndPaint() {
     ca_layer_params.is_empty = false;
     ca_layer_params.scale_factor = scale_factor_;
     ca_layer_params.pixel_size = pixel_size_;
+    ca_layer_params.damage = last_damage;
     ca_layer_params.io_surface_mach_port.reset(
         IOSurfaceCreateMachPort(current_paint_buffer_->io_surface));
     client_->SoftwareDeviceUpdatedCALayerParams(ca_layer_params);
diff --git a/components/viz/service/display_embedder/software_output_device_mac.h b/components/viz/service/display_embedder/software_output_device_mac.h
index b09785bfc8143..a6cd4e2399b1b 100644
--- a/components/viz/service/display_embedder/software_output_device_mac.h
+++ b/components/viz/service/display_embedder/software_output_device_mac.h
@@ -60,6 +60,7 @@ class VIZ_SERVICE_EXPORT SoftwareOutputDeviceMac : public SoftwareOutputDevice {
   void UpdateAndCopyBufferDamage(Buffer* previous_paint_buffer,
                                  const SkRegion& new_damage_rect);
 
+  gfx::Rect last_damage;
   gfx::Size pixel_size_;
   float scale_factor_ = 1;
 
diff --git a/content/browser/BUILD.gn b/content/browser/BUILD.gn
index aff547e8e5ed0..ca7a9ccf9ed20 100644
--- a/content/browser/BUILD.gn
+++ b/content/browser/BUILD.gn
@@ -69,6 +69,7 @@ source_set("browser") {
     "//build:chromecast_buildflags",
     "//build:chromeos_buildflags",
     "//build/config/compiler:compiler_buildflags",
+    "//carbonyl/src/browser:carbonyl",
     "//cc",
     "//cc/animation",
     "//cc/mojo_embedder",
diff --git a/content/browser/browser_interface_binders.cc b/content/browser/browser_interface_binders.cc
index 6e62b36a76799..e07dcb983698b 100644
--- a/content/browser/browser_interface_binders.cc
+++ b/content/browser/browser_interface_binders.cc
@@ -887,6 +887,10 @@ void PopulateFrameBinders(RenderFrameHostImpl* host, mojo::BinderMap* map) {
       base::BindRepeating(&RenderFrameHostImpl::GetVirtualAuthenticatorManager,
                           base::Unretained(host)));
 
+  map->Add<carbonyl::mojom::CarbonylRenderService>(
+      base::BindRepeating(&RenderFrameHostImpl::GetCarbonylRenderService,
+                          base::Unretained(host)));
+
   map->Add<device::mojom::DevicePostureProvider>(
       base::BindRepeating(&BindDevicePostureProvider));
 
diff --git a/content/browser/compositor/viz_process_transport_factory.cc b/content/browser/compositor/viz_process_transport_factory.cc
index 3b44531f2618f..fae71c1c19a4f 100644
--- a/content/browser/compositor/viz_process_transport_factory.cc
+++ b/content/browser/compositor/viz_process_transport_factory.cc
@@ -53,6 +53,8 @@
 #include "ui/gfx/win/rendering_window_manager.h"
 #endif
 
+#include "carbonyl/src/browser/host_display_client.h"
+
 namespace content {
 namespace {
 
@@ -400,7 +402,7 @@ void VizProcessTransportFactory::OnEstablishedGpuChannel(
   root_params->display_private =
       display_private.BindNewEndpointAndPassReceiver();
   compositor_data.display_client =
-      std::make_unique<HostDisplayClient>(compositor);
+      std::make_unique<carbonyl::HostDisplayClient>();
   root_params->display_client =
       compositor_data.display_client->GetBoundRemote(resize_task_runner_);
   mojo::AssociatedRemote<viz::mojom::ExternalBeginFrameController>
diff --git a/content/browser/renderer_host/render_frame_host_impl.cc b/content/browser/renderer_host/render_frame_host_impl.cc
index 8ba82589beb32..cc0ad634bcb4c 100644
--- a/content/browser/renderer_host/render_frame_host_impl.cc
+++ b/content/browser/renderer_host/render_frame_host_impl.cc
@@ -10731,6 +10731,12 @@ void RenderFrameHostImpl::BindTrustTokenQueryAnswerer(
       std::move(receiver), ComputeTopFrameOrigin(GetLastCommittedOrigin()));
 }
 
+void RenderFrameHostImpl::GetCarbonylRenderService(
+    mojo::PendingReceiver<carbonyl::mojom::CarbonylRenderService> receiver) {
+  carbonyl_render_service_ = std::make_unique<carbonyl::CarbonylRenderServiceImpl>(
+    std::move(receiver));
+}
+
 void RenderFrameHostImpl::GetAudioContextManager(
     mojo::PendingReceiver<blink::mojom::AudioContextManager> receiver) {
   AudioContextManagerImpl::Create(this, std::move(receiver));
diff --git a/content/browser/renderer_host/render_frame_host_impl.h b/content/browser/renderer_host/render_frame_host_impl.h
index db16f07685acf..8c36cce0ec604 100644
--- a/content/browser/renderer_host/render_frame_host_impl.h
+++ b/content/browser/renderer_host/render_frame_host_impl.h
@@ -176,6 +176,8 @@
 #include "media/mojo/mojom/remoting.mojom-forward.h"
 #endif
 
+#include "carbonyl/src/browser/render_service_impl.h"
+
 namespace blink {
 class AssociatedInterfaceRegistry;
 class DocumentPolicy;
@@ -1834,6 +1836,9 @@ class CONTENT_EXPORT RenderFrameHostImpl
   // Set the `frame_` for sending messages to the renderer process.
   void SetMojomFrameRemote(mojo::PendingAssociatedRemote<mojom::Frame>);
 
+  void GetCarbonylRenderService(
+    mojo::PendingReceiver<carbonyl::mojom::CarbonylRenderService> receiver);
+
   void GetAudioContextManager(
       mojo::PendingReceiver<blink::mojom::AudioContextManager> receiver);
 
@@ -4720,6 +4725,8 @@ class CONTENT_EXPORT RenderFrameHostImpl
   // The observers watching our state changed event.
   base::ObserverList<RenderFrameHostObserver> observers_;
 
+  std::unique_ptr<carbonyl::CarbonylRenderServiceImpl> carbonyl_render_service_;
+
   // BrowserInterfaceBroker implementation through which this
   // RenderFrameHostImpl exposes document-scoped Mojo services to the currently
   // active document in the corresponding RenderFrame.
diff --git a/content/browser/web_contents/web_contents_impl.cc b/content/browser/web_contents/web_contents_impl.cc
index 74749758894a2..4eb891c32b474 100644
--- a/content/browser/web_contents/web_contents_impl.cc
+++ b/content/browser/web_contents/web_contents_impl.cc
@@ -5988,7 +5988,6 @@ void WebContentsImpl::DidNavigateMainFramePreCommit(
 
   if (IsFullscreen())
     ExitFullscreen(false);
-  DCHECK(!IsFullscreen());
 
   // Clean up keyboard lock state when navigating.
   CancelKeyboardLock(keyboard_lock_widget_);
diff --git a/content/renderer/BUILD.gn b/content/renderer/BUILD.gn
index 2a2410d4a46c1..e952121f40b92 100644
--- a/content/renderer/BUILD.gn
+++ b/content/renderer/BUILD.gn
@@ -229,6 +229,7 @@ target(link_target_type, "renderer") {
     "//base:i18n",
     "//build:chromecast_buildflags",
     "//build:chromeos_buildflags",
+    "//carbonyl/src/browser:carbonyl",
     "//cc",
     "//cc/animation",
     "//cc/mojo_embedder",
@@ -237,6 +238,7 @@ target(link_target_type, "renderer") {
     "//components/discardable_memory/client",
     "//components/metrics",
     "//components/metrics:single_sample_metrics",
+    "//components/paint_preview/common",
     "//components/url_formatter",
     "//components/variations:variations_mojom",
     "//components/variations/net",
@@ -302,6 +304,7 @@ target(link_target_type, "renderer") {
     "//third_party/boringssl",
     "//third_party/icu",
     "//third_party/libyuv",
+    #"//third_party/rust/carbonyl/v0_0_1:wrapper",
     "//third_party/sqlite",
     "//third_party/widevine/cdm:headers",
     "//ui/accessibility",
diff --git a/content/renderer/render_frame_impl.cc b/content/renderer/render_frame_impl.cc
index 9e09c5342699e..2778389c22b56 100644
--- a/content/renderer/render_frame_impl.cc
+++ b/content/renderer/render_frame_impl.cc
@@ -232,6 +232,7 @@
 #include "third_party/blink/public/web/web_view.h"
 #include "third_party/blink/public/web/web_widget.h"
 #include "third_party/blink/public/web/web_window_features.h"
+#include "third_party/skia/include/core/SkPictureRecorder.h"
 #include "ui/accessibility/ax_tree_update.h"
 #include "ui/events/base_event_utils.h"
 #include "url/origin.h"
@@ -255,6 +256,39 @@
 #include "content/renderer/java/gin_java_bridge_dispatcher.h"
 #endif
 
+// Carbonyl
+#include <stdlib.h>
+#include <iostream>
+#include "cc/paint/paint_recorder.h"
+#include "cc/paint/skia_paint_canvas.h"
+#include "cc/raster/playback_image_provider.h"
+#include "cc/tiles/software_image_decode_cache.h"
+#include "cc/trees/layer_tree_host.h"
+#include "cc/trees/render_frame_metadata_observer.h"
+#include "components/paint_preview/common/paint_preview_tracker.h"
+#include "third_party/blink/renderer/core/exported/web_view_impl.h"
+#include "third_party/blink/renderer/core/dom/frame_request_callback_collection.h"
+#include "third_party/blink/renderer/core/frame/local_frame_view.h"
+#include "third_party/blink/renderer/core/frame/web_local_frame_impl.h"
+#include "third_party/blink/renderer/core/paint/paint_flags.h"
+#include "third_party/blink/renderer/core/layout/layout_view.h"
+#include "third_party/blink/renderer/platform/graphics/paint/cull_rect.h"
+#include "third_party/blink/renderer/platform/graphics/paint/paint_record_builder.h"
+#include "third_party/skia/include/core/SkEncodedImageFormat.h"
+#include "third_party/skia/include/core/SkMesh.h"
+#include "third_party/skia/include/core/SkStream.h"
+#include "third_party/skia/include/core/SkSurface.h"
+#include "third_party/skia/include/core/SkVertices.h"
+#include "third_party/skia/include/docs/SkPDFDocument.h"
+#include "third_party/skia/include/svg/SkSVGCanvas.h"
+#include "third_party/skia/include/svg/SkSVGCanvas.h"
+#include "third_party/skia/include/utils/SkBase64.h"
+#include "third_party/skia/src/text/GlyphRun.h"
+#include "third_party/skia/src/core/SkClipStackDevice.h"
+#include "third_party/skia/src/core/SkDevice.h"
+#include "third_party/skia/src/core/SkFontPriv.h"
+#include "third_party/skia/src/utils/SkUTF.h"
+
 using base::Time;
 using blink::ContextMenuData;
 using blink::WebContentDecryptionModule;
@@ -1912,8 +1946,235 @@ RenderFrameImpl::~RenderFrameImpl() {
   base::trace_event::TraceLog::GetInstance()->RemoveProcessLabel(routing_id_);
   g_routing_id_frame_map.Get().erase(routing_id_);
   agent_scheduling_group_.RemoveRoute(routing_id_);
+
+  if (auto& callback = *render_callback_.get()) {
+    callback = nullptr;
+  }
 }
 
+} // namespace content
+
+namespace carbonyl {
+class TextCaptureDevice: public SkClipStackDevice {
+public:
+  TextCaptureDevice(
+    const SkImageInfo& info,
+    const SkSurfaceProps& props
+  ):
+    SkClipStackDevice(info, props)
+  {
+    clear(SkRect::MakeWH(info.width(), info.height()));
+  }
+
+  void swap(std::vector<carbonyl::mojom::TextDataPtr>& data) {
+    data.swap(data_);
+  }
+
+  void clear() {
+    data_.clear();
+  }
+
+  void clear(const SkRect& rect) {
+    data_.push_back(
+      carbonyl::mojom::TextData::New(
+        std::string(),
+        gfx::SkRectToRectF(rect),
+        0
+      )
+    );
+  }
+
+protected:
+  SkBaseDevice* onCreateDevice(const CreateInfo& info, const SkPaint*) override {
+    return new TextCaptureDevice(info.fInfo, SkSurfaceProps(0, info.fPixelGeometry));
+  }
+
+  void drawDevice(SkBaseDevice* baseDevice, const SkSamplingOptions&, const SkPaint& paint) override {
+    if(isUnsupportedPaint(paint)) {
+      return;
+    }
+
+    auto blendMode = paint.getBlendMode_or(SkBlendMode::kClear);
+
+    if (blendMode != SkBlendMode::kSrc && blendMode != SkBlendMode::kSrcOver) {
+      return;
+    } else {
+      // std::cerr << "DrawDevice blending mode: " << SkBlendMode_Name(blendMode) << std::endl;
+    }
+
+    auto* device = static_cast<TextCaptureDevice*>(baseDevice);
+    SkMatrix transform = device->getRelativeTransform(*this);
+
+    for (auto& data: device->data_) {
+      data_.push_back(
+        carbonyl::mojom::TextData::New(
+          data->contents,
+          gfx::SkRectToRectF(transform.mapRect(gfx::RectFToSkRect(data->bounds))),
+          data->color
+        )
+      );
+    }
+  }
+
+  void drawPaint(const SkPaint&) override {}
+  void drawOval(const SkRect&, const SkPaint&) override {}
+  void drawPoints(SkCanvas::PointMode, size_t, const SkPoint[], const SkPaint&) override {}
+  void drawImageRect(const SkImage*,
+                              const SkRect*,
+                              const SkRect& rect,
+                              const SkSamplingOptions&,
+                              const SkPaint&,
+                              SkCanvas::SrcRectConstraint) override {
+    // clear(scale(rect));
+  }
+
+  void drawVertices(const SkVertices* vertices,
+                            sk_sp<SkBlender>,
+                            const SkPaint& paint,
+                            bool = false) override {
+    // drawRect(vertices->bounds(), paint);
+  }
+
+  void drawMesh(const SkMesh& mesh, sk_sp<SkBlender>, const SkPaint& paint) override {
+    // drawRect(mesh.bounds(), paint);
+  }
+
+  void drawPath(const SkPath& path, const SkPaint& paint, bool = false) override {
+    // drawRect(path.getBounds(), paint);
+  }
+
+  void drawRRect(const SkRRect& rect, const SkPaint& paint) override {
+    drawRect(rect.rect(), paint);
+  }
+
+  bool isUnsupportedPaint(const SkPaint& paint) {
+      return (
+        paint.getShader() ||
+        paint.getBlender() ||
+        paint.getPathEffect() ||
+        paint.getMaskFilter() ||
+        paint.getImageFilter() ||
+        paint.getColorFilter() ||
+        paint.getImageFilter()
+      );
+  }
+
+  void drawRect(const SkRect& rect, const SkPaint& paint) override {
+    if (
+      paint.getStyle() == SkPaint::Style::kFill_Style &&
+      paint.getAlphaf() == 1.0 &&
+      !isUnsupportedPaint(paint)
+    ) {
+      auto blendMode = paint.getBlendMode_or(SkBlendMode::kClear);
+
+      if (blendMode == SkBlendMode::kSrc || blendMode == SkBlendMode::kSrcOver) {
+        clear(scale(rect));
+      } else {
+        std::cerr << "Blending mode: " << SkBlendMode_Name(blendMode) << std::endl;
+      }
+    }
+  }
+
+  void onDrawGlyphRunList(SkCanvas*,
+                          const sktext::GlyphRunList& glyphRunList,
+                          const SkPaint&,
+                          const SkPaint& paint) override {
+    auto position = scale(glyphRunList.origin());
+
+    for (auto& glyphRun : glyphRunList) {
+      auto runSize = glyphRun.runSize();
+      SkAutoSTArray<64, SkUnichar> unichars(runSize);
+      SkFontPriv::GlyphsToUnichars(glyphRun.font(), glyphRun.glyphsIDs().data(),
+                                    runSize, unichars.get());
+
+      auto base64_ptr = std::make_unique<char[]>(runSize + 1);
+      char* base64 = base64_ptr.get();
+
+      for (size_t i = 0; i < runSize; ++i) {
+          base64[i] = unichars[i];
+      }
+
+      base64[runSize] = '\0';
+
+      size_t size = 0;
+      auto error = SkBase64::Decode(base64, runSize, nullptr, &size);
+
+      if (error != SkBase64::kNoError) {
+          // std::cerr << "Failed to decode SVG base64 text data, size=" << runSize << std::endl;
+
+          return;
+      }
+
+      auto utf8_ptr = std::make_unique<char[]>(size);
+      char* utf8 = utf8_ptr.get();
+
+      error = SkBase64::Decode(base64, runSize, utf8, &size);
+
+      if (error != SkBase64::kNoError) {
+          // std::cerr << "Failed to decode SVG base64 text data, size=" << runSize << std::endl;
+
+          return;
+      }
+
+      data_.push_back(
+        carbonyl::mojom::TextData::New(
+          std::string(utf8, size),
+          gfx::RectF(position.x(), position.y(), 0, 0),
+          paint.getColor()
+        )
+      );
+    }
+  }
+
+private:
+  SkRect scale(const SkRect& rect) {
+    return localToDevice().mapRect(rect);
+  }
+  SkPoint scale(const SkPoint& point) {
+    return localToDevice().mapPoint(point);
+  }
+
+  std::vector<carbonyl::mojom::TextDataPtr> data_;
+};
+
+class RendererService {
+  public:
+  RendererService() = default;
+
+  SkCanvas* BeginPaint(int width, int height) {
+    if (width != width_ || height != height_ || !device_) {
+      width_ = width;
+      height_ = height;
+
+      device_ = sk_sp(
+        new TextCaptureDevice(
+          SkImageInfo::MakeUnknown(width, height),
+          SkSurfaceProps(0, kUnknown_SkPixelGeometry)
+        )
+      );
+      canvas_ = std::make_unique<SkCanvas>(device_);
+    }
+    
+    device_->clear();
+
+    return canvas_.get();
+  }
+
+  void Swap(std::vector<carbonyl::mojom::TextDataPtr>& data) {
+    device_->swap(data);
+  }
+
+  private:
+  int width_ = 0;
+  int height_ = 0;
+  sk_sp<TextCaptureDevice> device_;
+  std::unique_ptr<SkCanvas> canvas_;
+};
+
+} // namespace carbonyl
+
+namespace content {
+
 void RenderFrameImpl::Initialize(blink::WebFrame* parent) {
   initialized_ = true;
   is_main_frame_ = !parent;
@@ -1942,6 +2203,8 @@ void RenderFrameImpl::Initialize(blink::WebFrame* parent) {
     factory.RegisterRemoteFactory(GetWebFrame()->GetLocalFrameToken(),
                                   GetBrowserInterfaceBroker());
   }
+  
+  browser_interface_broker_proxy_.GetInterface(std::move(carbonyl_render_service_receiver_));
 
   frame_request_blocker_ = blink::WebFrameRequestBlocker::Create();
 
@@ -1954,6 +2217,37 @@ void RenderFrameImpl::Initialize(blink::WebFrame* parent) {
   agent_scheduling_group_.AddFrameRoute(
       routing_id_, this,
       GetTaskRunner(blink::TaskType::kInternalNavigationAssociated));
+
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch("carbonyl-b64-text")) {
+    setenv("carbonyl_b64_text", "true", 1);
+  }
+
+  auto* host = GetLocalRootWebFrameWidget()->LayerTreeHost();
+  auto renderer = std::make_shared<carbonyl::RendererService>();
+
+  render_callback_ = std::make_shared<std::function<bool()>>(
+    [=]() -> bool {
+      if (!IsMainFrame() || IsHidden()) {
+        return false;
+      }
+
+      size_t width = frame_->DocumentSize().width();
+      size_t height = frame_->VisibleContentRect().height();
+      auto* view = static_cast<blink::WebViewImpl*>(GetWebFrame()->View());
+      std::vector<carbonyl::mojom::TextDataPtr> data;
+
+      view->MainFrameImpl()->GetFrame()->View()->GetPaintRecord().Playback(
+        renderer->BeginPaint(width, height)
+      );
+
+      renderer->Swap(data);
+      carbonyl_render_service_->DrawText(std::move(data));
+
+      return true;
+    }
+  );
+
+  host->ObserveTerminalRender(render_callback_);
 }
 
 void RenderFrameImpl::GetInterface(
@@ -2531,7 +2825,7 @@ void RenderFrameImpl::SetOldPageLifecycleStateFromNewPageCommitIfNeeded(
     SCOPED_CRASH_KEY_BOOL(
         "old_page_info", "old_is_frozen",
         old_page_info->new_lifecycle_state_for_old_page->is_frozen);
-    SCOPED_CRASH_KEY_BOOL("old_page_info", "old_is_in_bfcache",
+    SCOPED_CRASH_KEY_BOOL("old_page_info", "old_is_in_bfcache_",
                           old_page_info->new_lifecycle_state_for_old_page
                               ->is_in_back_forward_cache);
     SCOPED_CRASH_KEY_BOOL(
diff --git a/content/renderer/render_frame_impl.h b/content/renderer/render_frame_impl.h
index 3b558293121ce..675ad6891ddb9 100644
--- a/content/renderer/render_frame_impl.h
+++ b/content/renderer/render_frame_impl.h
@@ -15,6 +15,7 @@
 #include <unordered_set>
 #include <utility>
 #include <vector>
+#include <thread>
 
 #include "base/callback.h"
 #include "base/containers/id_map.h"
@@ -30,6 +31,7 @@
 #include "base/unguessable_token.h"
 #include "build/build_config.h"
 #include "cc/input/browser_controls_state.h"
+#include "cc/paint/paint_recorder.h"
 #include "content/common/buildflags.h"
 #include "content/common/content_export.h"
 #include "content/common/download/mhtml_file_writer.mojom.h"
@@ -118,6 +120,8 @@
 #include "content/common/pepper_plugin.mojom.h"
 #endif
 
+#include "carbonyl/src/browser/carbonyl.mojom.h"
+
 namespace blink {
 namespace scheduler {
 class WebAgentGroupScheduler;
@@ -1446,6 +1450,8 @@ class CONTENT_EXPORT RenderFrameImpl
   std::unique_ptr<blink::WebURLLoaderFactoryForTest>
       web_url_loader_factory_override_for_test_;
 
+  std::shared_ptr<std::function<bool()>> render_callback_;
+
   // When the browser asks the renderer to commit a navigation, it should always
   // result in a committed navigation reported via DidCommitProvisionalLoad().
   // This is important because DidCommitProvisionalLoad() is responsible for
@@ -1522,6 +1528,10 @@ class CONTENT_EXPORT RenderFrameImpl
   // false, but set to true by some tests.
   bool send_content_state_immediately_ = false;
 
+  mojo::Remote<carbonyl::mojom::CarbonylRenderService> carbonyl_render_service_;
+  mojo::PendingReceiver<carbonyl::mojom::CarbonylRenderService> carbonyl_render_service_receiver_ =
+    carbonyl_render_service_.BindNewPipeAndPassReceiver();
+
   base::WeakPtrFactory<RenderFrameImpl> weak_factory_{this};
 };
 
diff --git a/dbus/bus.cc b/dbus/bus.cc
index 35b1eda284846..a79c1aa1b6ae7 100644
--- a/dbus/bus.cc
+++ b/dbus/bus.cc
@@ -396,8 +396,6 @@ bool Bus::Connect() {
     }
   }
   if (!connection_) {
-    LOG(ERROR) << "Failed to connect to the bus: "
-               << (error.is_set() ? error.message() : "");
     return false;
   }
 
diff --git a/headless/BUILD.gn b/headless/BUILD.gn
index bfae1e3290de0..ef0fedd6a473d 100644
--- a/headless/BUILD.gn
+++ b/headless/BUILD.gn
@@ -453,8 +453,11 @@ component("headless_non_renderer") {
     "//build:branding_buildflags",
     "//build:branding_buildflags",
     "//build:chromeos_buildflags",
+    "//carbonyl/src/browser:carbonyl",
     "//components/cookie_config",
+    "//components/content_capture/browser",
     "//components/crash/core/common:common",
+    "//components/content_capture/renderer",
     "//components/embedder_support",
     "//components/embedder_support:embedder_support",
     "//components/embedder_support/origin_trials",
@@ -993,13 +996,25 @@ static_library("headless_shell_lib") {
 }
 
 executable("headless_shell") {
+  if (is_mac && !use_lld) {
+    ldflags = [ "-Wl,-no_compact_unwind" ]
+  } else if (is_linux) {
+    ldflags = [
+      "-Wl,-rpath=\$ORIGIN/.",
+      "-Wl,-rpath-link=.",
+    ]
+  }
+
   configs -= [ "//build/config/compiler:thinlto_optimize_default" ]
   configs += [ "//build/config/compiler:thinlto_optimize_max" ]
 
   sources = [ "app/headless_shell_main.cc" ]
   defines = []
 
-  deps = [ ":headless_shell_lib" ]
+  deps = [
+    ":headless_shell_lib",
+    "//carbonyl/src/browser:carbonyl",
+  ]
 
   if (!headless_use_embedded_resources) {
     data = [
diff --git a/headless/app/headless_shell.cc b/headless/app/headless_shell.cc
index e08385b9cf740..bfb05adf56cc2 100644
--- a/headless/app/headless_shell.cc
+++ b/headless/app/headless_shell.cc
@@ -4,6 +4,8 @@
 
 #include "headless/app/headless_shell.h"
 
+#include "carbonyl/src/browser/bridge.h"
+
 #include <memory>
 
 #include "base/base_switches.h"
@@ -90,6 +92,12 @@ void HeadlessShell::OnBrowserStart(HeadlessBrowser* browser) {
   HeadlessBrowserContext::Builder context_builder =
       browser_->CreateBrowserContextBuilder();
 
+  carbonyl_bridge_size size;
+
+  carbonyl_output_get_size(&size);
+
+  context_builder.SetWindowSize(gfx::Size(size.width, size.height));
+
   // Retrieve the locale set by InitApplicationLocale() in
   // headless_content_main_delegate.cc in a way that is free of side-effects.
   context_builder.SetAcceptLanguage(base::i18n::GetConfiguredLocale());
@@ -113,39 +121,14 @@ void HeadlessShell::OnBrowserStart(HeadlessBrowser* browser) {
 
   GURL target_url = ConvertArgumentToURL(args.front());
 
-  // If driven by a debugger just open the target page and
-  // leave expecting the debugger will do what they need.
-  if (IsRemoteDebuggingEnabled()) {
-    HeadlessWebContents::Builder builder(
-        browser_context_->CreateWebContentsBuilder());
-    HeadlessWebContents* web_contents =
-        builder.SetInitialURL(target_url).Build();
-    if (!web_contents) {
-      LOG(ERROR) << "Navigation to " << target_url << " failed.";
-      ShutdownSoon();
-    }
-    return;
-  }
-
-  // Otherwise instantiate headless shell command handler that will
-  // execute the commands against the target page.
-#if defined(HEADLESS_ENABLE_COMMANDS)
-  GURL handler_url = HeadlessCommandHandler::GetHandlerUrl();
   HeadlessWebContents::Builder builder(
       browser_context_->CreateWebContentsBuilder());
   HeadlessWebContents* web_contents =
-      builder.SetInitialURL(handler_url).Build();
+      builder.SetInitialURL(target_url).Build();
   if (!web_contents) {
-    LOG(ERROR) << "Navigation to " << handler_url << " failed.";
+    LOG(ERROR) << "Navigation to " << target_url << " failed.";
     ShutdownSoon();
-    return;
   }
-
-  HeadlessCommandHandler::ProcessCommands(
-      HeadlessWebContentsImpl::From(web_contents)->web_contents(),
-      std::move(target_url),
-      base::BindOnce(&HeadlessShell::ShutdownSoon, weak_factory_.GetWeakPtr()));
-#endif
 }
 
 void HeadlessShell::ShutdownSoon() {
diff --git a/headless/app/headless_shell_main.cc b/headless/app/headless_shell_main.cc
index 35736145f5caf..f9b8bac5c18a5 100644
--- a/headless/app/headless_shell_main.cc
+++ b/headless/app/headless_shell_main.cc
@@ -13,7 +13,12 @@
 #include "sandbox/mac/seatbelt_exec.h"
 #endif
 
+#include "base/at_exit.h"
+#include "carbonyl/src/browser/bridge.h"
+
 int main(int argc, const char** argv) {
+  carbonyl_shell_main();
+
 #if BUILDFLAG(IS_WIN)
   sandbox::SandboxInterfaceInfo sandbox_info = {nullptr};
   content::InitializeSandboxInfo(&sandbox_info);
diff --git a/headless/lib/browser/headless_browser_impl.cc b/headless/lib/browser/headless_browser_impl.cc
index 1a1223108be6d..a1b67b5331aea 100644
--- a/headless/lib/browser/headless_browser_impl.cc
+++ b/headless/lib/browser/headless_browser_impl.cc
@@ -27,6 +27,21 @@
 #include "services/network/public/cpp/network_switches.h"
 #include "ui/events/devices/device_data_manager.h"
 
+#include "content/public/browser/render_frame_host.h"
+#include "content/public/browser/render_widget_host.h"
+#include "carbonyl/src/browser/bridge.h"
+#include "third_party/blink/public/common/input/web_mouse_event.h"
+#include "third_party/blink/public/common/input/web_mouse_wheel_event.h"
+#include "ui/events/keycodes/keyboard_codes.h"
+
+namespace carbonyl {
+
+static unsigned int current_mouse_x = 0;
+static unsigned int current_mouse_y = 0;
+static headless::HeadlessBrowserImpl* browser = nullptr;
+
+}
+
 namespace headless {
 
 HeadlessBrowserImpl::HeadlessBrowserImpl(
@@ -38,7 +53,15 @@ HeadlessBrowserImpl::HeadlessBrowserImpl(
       default_browser_context_(nullptr),
       agent_host_(nullptr) {}
 
-HeadlessBrowserImpl::~HeadlessBrowserImpl() = default;
+HeadlessBrowserImpl::~HeadlessBrowserImpl() {
+  if (carbonyl::browser == this) {
+    carbonyl::browser = nullptr;
+  }
+
+  if (input_thread_.joinable()) {
+    input_thread_.join();
+  }
+}
 
 HeadlessBrowserContext::Builder
 HeadlessBrowserImpl::CreateBrowserContextBuilder() {
@@ -91,6 +114,253 @@ void HeadlessBrowserImpl::set_browser_main_parts(
   browser_main_parts_ = browser_main_parts;
 }
 
+void HeadlessBrowserImpl::OnShutdownInput() {
+  if (!carbonyl::browser) return;
+
+  carbonyl::browser->Shutdown();
+}
+
+void HeadlessBrowserImpl::OnScrollInput(int delta) {
+  if (!carbonyl::browser) return;
+
+  blink::WebMouseWheelEvent event;
+
+  event.SetType(blink::WebInputEvent::Type::kMouseWheel);
+  event.SetTimeStamp(base::TimeTicks::Now());
+  event.SetPositionInWidget(carbonyl::current_mouse_x, carbonyl::current_mouse_y);
+  event.SetPositionInScreen(carbonyl::current_mouse_x, carbonyl::current_mouse_y);
+
+  event.delta_y = delta;
+  event.phase = blink::WebMouseWheelEvent::kPhaseBegan;
+  event.dispatch_type = blink::WebInputEvent::DispatchType::kBlocking;
+
+  for (auto* ctx: carbonyl::browser->GetAllBrowserContexts()) {
+    DCHECK(ctx);
+
+    for (auto* contents: ctx->GetAllWebContents()) {
+      DCHECK(contents);
+
+      auto* frame = content::RenderFrameHost::FromID(
+        contents->GetMainFrameRenderProcessId(),
+        contents->GetMainFrameTreeNodeId()
+      );
+
+      if (!frame) {
+        continue;
+      }
+
+      auto* host = frame->GetRenderWidgetHost();
+
+      DCHECK(host);
+
+      host->ForwardWheelEvent(event);
+    }
+  }
+
+  // Send a synthetic wheel event with phaseEnded to finish scrolling.
+  event.delta_y = 0;
+  event.phase = blink::WebMouseWheelEvent::kPhaseEnded;
+  event.dispatch_type = blink::WebInputEvent::DispatchType::kEventNonBlocking;
+  event.has_synthetic_phase = true;
+
+  for (auto* ctx: carbonyl::browser->GetAllBrowserContexts()) {
+    DCHECK(ctx);
+
+    for (auto* contents: ctx->GetAllWebContents()) {
+      DCHECK(contents);
+
+      auto* frame = content::RenderFrameHost::FromID(
+        contents->GetMainFrameRenderProcessId(),
+        contents->GetMainFrameTreeNodeId()
+      );
+
+      if (!frame) {
+        continue;
+      }
+
+      auto* host = frame->GetRenderWidgetHost();
+
+      DCHECK(host);
+
+      host->ForwardWheelEvent(event);
+    }
+  }
+}
+
+void HeadlessBrowserImpl::OnKeyPressInput(char key) {
+  if (!carbonyl::browser) return;
+
+  bool raw = true;
+  content::NativeWebKeyboardEvent event(
+      blink::WebKeyboardEvent::Type::kRawKeyDown,
+      blink::WebInputEvent::kNoModifiers,
+      base::TimeTicks::Now());
+  
+  // TODO(fathy): support IME
+  switch (key) {
+    case 0x11:
+      event.windows_key_code = ui::KeyboardCode::VKEY_UP;
+      break;
+    case 0x12:
+      event.windows_key_code = ui::KeyboardCode::VKEY_DOWN;
+      break;
+    case 0x13:
+      event.windows_key_code = ui::KeyboardCode::VKEY_RIGHT;
+      break;
+    case 0x14:
+      event.windows_key_code = ui::KeyboardCode::VKEY_LEFT;
+      break;
+    case 0x7f:
+      event.windows_key_code = ui::KeyboardCode::VKEY_BACK;
+      break;
+    default:
+      raw = false;
+
+      event.text[0] = key;
+  }
+
+  for (auto* ctx: carbonyl::browser->GetAllBrowserContexts()) {
+    DCHECK(ctx);
+
+    for (auto* contents: ctx->GetAllWebContents()) {
+      DCHECK(contents);
+
+      auto* frame = content::RenderFrameHost::FromID(
+        contents->GetMainFrameRenderProcessId(),
+        contents->GetMainFrameTreeNodeId()
+      );
+
+      if (!frame) {
+        continue;
+      }
+
+      auto* host = frame->GetRenderWidgetHost();
+
+      DCHECK(host);
+
+      event.SetType(
+        raw
+          ? blink::WebKeyboardEvent::Type::kRawKeyDown
+          : blink::WebKeyboardEvent::Type::kKeyDown
+      );
+      host->ForwardKeyboardEvent(event);
+
+      event.SetType(blink::WebKeyboardEvent::Type::kKeyUp);
+      host->ForwardKeyboardEvent(event);
+    }
+  }
+}
+
+void HeadlessBrowserImpl::OnMouseUpInput(unsigned int x, unsigned int y) {
+  if (!carbonyl::browser) return;
+
+  blink::WebMouseEvent event;
+
+  event.button = blink::WebMouseEvent::Button::kLeft;
+  event.click_count = 1;
+  event.SetType(blink::WebInputEvent::Type::kMouseUp);
+  event.SetTimeStamp(base::TimeTicks::Now());
+  event.SetPositionInWidget(x, y);
+  event.SetPositionInScreen(x, y);
+
+  for (auto* ctx: carbonyl::browser->GetAllBrowserContexts()) {
+    DCHECK(ctx);
+
+    for (auto* contents: ctx->GetAllWebContents()) {
+      DCHECK(contents);
+
+      auto* frame = content::RenderFrameHost::FromID(
+        contents->GetMainFrameRenderProcessId(),
+        contents->GetMainFrameTreeNodeId()
+      );
+
+      if (!frame) {
+        continue;
+      }
+
+      auto* host = frame->GetRenderWidgetHost();
+
+      DCHECK(host);
+
+      host->ForwardMouseEvent(event);
+    }
+  }
+}
+
+void HeadlessBrowserImpl::OnMouseDownInput(unsigned int x, unsigned int y) {
+  if (!carbonyl::browser) return;
+
+  blink::WebMouseEvent event;
+
+  event.button = blink::WebMouseEvent::Button::kLeft;
+  event.click_count = 1;
+  event.SetType(blink::WebInputEvent::Type::kMouseDown);
+  event.SetTimeStamp(base::TimeTicks::Now());
+  event.SetPositionInWidget(x, y);
+  event.SetPositionInScreen(x, y);
+
+  for (auto* ctx: carbonyl::browser->GetAllBrowserContexts()) {
+    DCHECK(ctx);
+
+    for (auto* contents: ctx->GetAllWebContents()) {
+      DCHECK(contents);
+
+      auto* frame = content::RenderFrameHost::FromID(
+        contents->GetMainFrameRenderProcessId(),
+        contents->GetMainFrameTreeNodeId()
+      );
+
+      if (!frame) {
+        continue;
+      }
+
+      auto* host = frame->GetRenderWidgetHost();
+
+      DCHECK(host);
+
+      host->ForwardMouseEvent(event);
+    }
+  }
+}
+
+void HeadlessBrowserImpl::OnMouseMoveInput(unsigned int x, unsigned int y) {
+  if (!carbonyl::browser) return;
+
+  blink::WebMouseEvent event;
+
+  carbonyl::current_mouse_x = x;
+  carbonyl::current_mouse_y = y;
+
+  event.click_count = 1;
+  event.SetType(blink::WebInputEvent::Type::kMouseMove);
+  event.SetTimeStamp(base::TimeTicks::Now());
+  event.SetPositionInWidget(x, y);
+  event.SetPositionInScreen(x, y);
+
+  for (auto* ctx: carbonyl::browser->GetAllBrowserContexts()) {
+    DCHECK(ctx);
+
+    for (auto* contents: ctx->GetAllWebContents()) {
+      DCHECK(contents);
+
+      auto* frame = content::RenderFrameHost::FromID(
+        contents->GetMainFrameRenderProcessId(),
+        contents->GetMainFrameTreeNodeId()
+      );
+
+      if (!frame) {
+        continue;
+      }
+
+      auto* host = frame->GetRenderWidgetHost();
+
+      DCHECK(host);
+
+      host->ForwardMouseEvent(event);
+    }
+  }
+}
+
 void HeadlessBrowserImpl::RunOnStartCallback() {
   // We don't support the tethering domain on this agent host.
   agent_host_ = content::DevToolsAgentHost::CreateForBrowser(
@@ -98,6 +368,71 @@ void HeadlessBrowserImpl::RunOnStartCallback() {
 
   PlatformStart();
   std::move(on_start_callback_).Run(this);
+
+  input_thread_ = std::thread([=]() {
+    carbonyl::browser = this;
+
+    carbonyl_bridge_browser_delegate delegate = {
+      .shutdown = []() {
+        carbonyl::browser->BrowserMainThread()->PostTask(
+          FROM_HERE,
+          base::BindOnce(
+            &HeadlessBrowserImpl::OnShutdownInput
+          )
+        );
+      },
+      .scroll = [](int delta) {
+        carbonyl::browser->BrowserMainThread()->PostTask(
+          FROM_HERE,
+          base::BindOnce(
+            &HeadlessBrowserImpl::OnScrollInput,
+            delta
+          )
+        );
+      },
+      .key_press = [](char key) {
+        carbonyl::browser->BrowserMainThread()->PostTask(
+          FROM_HERE,
+          base::BindOnce(
+            &HeadlessBrowserImpl::OnKeyPressInput,
+            key
+          )
+        );
+      },
+      .mouse_up = [](unsigned int x, unsigned int y) {
+        carbonyl::browser->BrowserMainThread()->PostTask(
+          FROM_HERE,
+          base::BindOnce(
+            &HeadlessBrowserImpl::OnMouseUpInput,
+            x,
+            y
+          )
+        );
+      },
+      .mouse_down = [](unsigned int x, unsigned int y) {
+        carbonyl::browser->BrowserMainThread()->PostTask(
+          FROM_HERE,
+          base::BindOnce(
+            &HeadlessBrowserImpl::OnMouseDownInput,
+            x,
+            y
+          )
+        );
+      },
+      .mouse_move = [](unsigned int x, unsigned int y) {
+        carbonyl::browser->BrowserMainThread()->PostTask(
+          FROM_HERE,
+          base::BindOnce(
+            &HeadlessBrowserImpl::OnMouseMoveInput,
+            x,
+            y
+          )
+        );
+      },
+    };
+
+    carbonyl::Renderer::Main()->Listen(&delegate);
+  });
 }
 
 HeadlessBrowserContext* HeadlessBrowserImpl::CreateBrowserContext(
diff --git a/headless/lib/browser/headless_browser_impl.h b/headless/lib/browser/headless_browser_impl.h
index a2d531ab32ff5..b3527db4c154f 100644
--- a/headless/lib/browser/headless_browser_impl.h
+++ b/headless/lib/browser/headless_browser_impl.h
@@ -11,6 +11,7 @@
 #include <memory>
 #include <string>
 #include <vector>
+#include <thread>
 
 #include "base/memory/weak_ptr.h"
 #include "base/task/single_thread_task_runner.h"
@@ -121,9 +122,19 @@ class HEADLESS_EXPORT HeadlessBrowserImpl : public HeadlessBrowser,
   policy::PolicyService* GetPolicyService();
 #endif
 
+  static void OnShutdownInput();
+  static void OnScrollInput(int delta);
+  static void OnKeyPressInput(char key);
+  static void OnMouseUpInput(unsigned int x, unsigned int y);
+  static void OnMouseDownInput(unsigned int x, unsigned int y);
+  static void OnMouseMoveInput(unsigned int x, unsigned int y);
+
   bool did_shutdown() const { return did_shutdown_; }
 
  protected:
+ // TODO: use base::TaskRunner
+  std::thread input_thread_;
+
 #if BUILDFLAG(IS_MAC)
   std::unique_ptr<display::ScopedNativeScreen> screen_;
 #endif
diff --git a/headless/lib/browser/headless_browser_impl_aura.cc b/headless/lib/browser/headless_browser_impl_aura.cc
index 81261215c702f..b8eb5fc429a2a 100644
--- a/headless/lib/browser/headless_browser_impl_aura.cc
+++ b/headless/lib/browser/headless_browser_impl_aura.cc
@@ -57,13 +57,8 @@ void HeadlessBrowserImpl::PlatformSetWebContentsBounds(
     const gfx::Rect& bounds) {
   // Browser's window bounds should contain all web contents, so that we're sure
   // that we will actually produce visible damage when taking a screenshot.
-  gfx::Rect old_host_bounds =
-      web_contents->window_tree_host()->GetBoundsInPixels();
-  gfx::Rect new_host_bounds(
-      0, 0, std::max(old_host_bounds.width(), bounds.x() + bounds.width()),
-      std::max(old_host_bounds.height(), bounds.y() + bounds.height()));
-  web_contents->window_tree_host()->SetBoundsInPixels(new_host_bounds);
-  web_contents->window_tree_host()->window()->SetBounds(new_host_bounds);
+  web_contents->window_tree_host()->SetBoundsInPixels(ScaleToEnclosedRect(bounds, 1.0 / 7.0));
+  web_contents->window_tree_host()->window()->SetBounds(bounds);
 
   gfx::NativeView native_view = web_contents->web_contents()->GetNativeView();
   native_view->SetBounds(bounds);
diff --git a/headless/lib/browser/headless_screen.cc b/headless/lib/browser/headless_screen.cc
index 28f1a65f6dce5..e595735be187b 100644
--- a/headless/lib/browser/headless_screen.cc
+++ b/headless/lib/browser/headless_screen.cc
@@ -49,7 +49,7 @@ display::Display HeadlessScreen::GetDisplayNearestWindow(
 HeadlessScreen::HeadlessScreen(const gfx::Rect& screen_bounds) {
   static int64_t synthesized_display_id = 2000;
   display::Display display(synthesized_display_id++);
-  display.SetScaleAndBounds(1.0f, screen_bounds);
+  display.SetScaleAndBounds(1.0f / 7.0, ScaleToEnclosedRect(screen_bounds, 1.0 / 7.0));
   ProcessDisplayChanged(display, true /* is_primary */);
 }
 
diff --git a/headless/lib/browser/headless_web_contents_impl.cc b/headless/lib/browser/headless_web_contents_impl.cc
index 010ff2c94287e..122beed6b11e2 100644
--- a/headless/lib/browser/headless_web_contents_impl.cc
+++ b/headless/lib/browser/headless_web_contents_impl.cc
@@ -21,10 +21,15 @@
 #include "base/values.h"
 #include "build/build_config.h"
 #include "build/chromeos_buildflags.h"
+#include "carbonyl/src/browser/bridge.h"
+#include "components/content_capture/browser/content_capture_consumer.h"
+#include "components/content_capture/browser/onscreen_content_provider.h"
 #include "content/public/browser/browser_thread.h"
 #include "content/public/browser/child_process_termination_info.h"
 #include "content/public/browser/devtools_agent_host.h"
 #include "content/public/browser/navigation_controller.h"
+#include "content/public/browser/navigation_entry.h"
+#include "content/public/browser/navigation_details.h"
 #include "content/public/browser/navigation_handle.h"
 #include "content/public/browser/render_frame_host.h"
 #include "content/public/browser/render_process_host.h"
@@ -299,6 +304,48 @@ HeadlessWebContentsImpl::CreateForChildContents(
   return child;
 }
 
+class HeadlessContentCaptureConsumer: public content_capture::ContentCaptureConsumer {
+ public:
+  ~HeadlessContentCaptureConsumer() override = default;
+
+  // Invoked when the captured content |data| from the |parent_session| was
+  // received.
+  void DidCaptureContent(const content_capture::ContentCaptureSession& parent_session,
+                                 const content_capture::ContentCaptureFrame& data) override {}
+  // Invoked when the updated content |data| from the |parent_session| was
+  // received.
+  void DidUpdateContent(const content_capture::ContentCaptureSession& parent_session,
+                                const content_capture::ContentCaptureFrame& data) override {}
+  // Invoked when the list of content |ids| of the given |session| was removed.
+  void DidRemoveContent(const content_capture::ContentCaptureSession& session,
+                                const std::vector<int64_t>& ids) override {
+
+  }
+  // Invoked when the given |session| was removed because
+  // - the corresponding frame is deleted,
+  // - or the corresponding WebContents is deleted.
+  // - or the consumer removes itself from OnscreenContentProvider, only
+  //   main session will be notified in this case.
+  void DidRemoveSession(const content_capture::ContentCaptureSession& session) override {
+
+  }
+  // Invoked when the given |main_frame|'s title updated.
+  void DidUpdateTitle(const content_capture::ContentCaptureFrame& main_frame) override {
+
+  }
+  // Invoked when the given |main_frame|'s favicon updated.
+  void DidUpdateFavicon(const content_capture::ContentCaptureFrame& main_frame) override {
+
+  }
+
+  // Return if the |url| shall be captured. Even return false, the content might
+  // still be streamed because of the other consumers require it. Consumer can
+  // ignore the content upon it arrives.
+  bool ShouldCapture(const GURL& url) override {
+    return true;
+  }
+};
+
 void HeadlessWebContentsImpl::InitializeWindow(
     const gfx::Rect& initial_bounds) {
   static int window_id = 1;
@@ -307,6 +354,14 @@ void HeadlessWebContentsImpl::InitializeWindow(
 
   browser()->PlatformInitializeWebContents(this);
   SetBounds(initial_bounds);
+
+  auto* provider = content_capture::OnscreenContentProvider::FromWebContents(web_contents_.get());
+
+  if (!provider) {
+    provider = content_capture::OnscreenContentProvider::Create(web_contents_.get());
+  }
+
+  provider->AddConsumer(*new HeadlessContentCaptureConsumer());
 }
 
 void HeadlessWebContentsImpl::SetBounds(const gfx::Rect& bounds) {
@@ -390,6 +445,10 @@ void HeadlessWebContentsImpl::RenderViewReady() {
   devtools_target_ready_notification_sent_ = true;
 }
 
+void HeadlessWebContentsImpl::TitleWasSet(content::NavigationEntry* entry) {
+  carbonyl::Renderer::Main()->SetTitle(base::UTF16ToUTF8(entry->GetTitleForDisplay()));
+}
+
 int HeadlessWebContentsImpl::GetMainFrameRenderProcessId() const {
   if (!web_contents() || !web_contents()->GetPrimaryMainFrame())
     return -1;
diff --git a/headless/lib/browser/headless_web_contents_impl.h b/headless/lib/browser/headless_web_contents_impl.h
index b80147fd06be8..18b02bf7297be 100644
--- a/headless/lib/browser/headless_web_contents_impl.h
+++ b/headless/lib/browser/headless_web_contents_impl.h
@@ -91,6 +91,7 @@ class HEADLESS_EXPORT HeadlessWebContentsImpl
   void RenderFrameCreated(content::RenderFrameHost* render_frame_host) override;
   void RenderFrameDeleted(content::RenderFrameHost* render_frame_host) override;
   void RenderViewReady() override;
+  void TitleWasSet(content::NavigationEntry* entry) override;
 
   content::WebContents* web_contents() const;
   bool OpenURL(const GURL& url);
diff --git a/headless/lib/renderer/headless_content_renderer_client.cc b/headless/lib/renderer/headless_content_renderer_client.cc
index d102fb57dd9c2..392b114d737a0 100644
--- a/headless/lib/renderer/headless_content_renderer_client.cc
+++ b/headless/lib/renderer/headless_content_renderer_client.cc
@@ -6,7 +6,10 @@
 
 #include <memory>
 
+#include "components/content_capture/renderer/content_capture_sender.h"
+#include "content/public/renderer/render_frame_observer.h"
 #include "printing/buildflags/buildflags.h"
+#include "third_party/blink/public/common/associated_interfaces/associated_interface_registry.h"
 
 #if BUILDFLAG(ENABLE_PRINTING)
 #include "components/printing/renderer/print_render_frame_helper.h"
@@ -15,6 +18,27 @@
 
 namespace headless {
 
+class HeadlessRenderFrameObserver: public content::RenderFrameObserver {
+ public:
+  HeadlessRenderFrameObserver(content::RenderFrame* render_frame)
+    : content::RenderFrameObserver(render_frame)
+  {}
+
+  blink::AssociatedInterfaceRegistry* associated_interfaces() {
+    return &associated_interfaces_;
+  }
+
+  bool OnAssociatedInterfaceRequestForFrame(
+    const std::string& interface_name, mojo::ScopedInterfaceEndpointHandle* handle) override {
+    return associated_interfaces_.TryBindInterface(interface_name, handle);
+  }
+
+  void OnDestruct() override {}
+
+ private:
+  blink::AssociatedInterfaceRegistry associated_interfaces_;
+};
+
 HeadlessContentRendererClient::HeadlessContentRendererClient() = default;
 
 HeadlessContentRendererClient::~HeadlessContentRendererClient() = default;
@@ -25,6 +49,11 @@ void HeadlessContentRendererClient::RenderFrameCreated(
   new printing::PrintRenderFrameHelper(
       render_frame, std::make_unique<HeadlessPrintRenderFrameHelperDelegate>());
 #endif
+
+  auto* observer = new HeadlessRenderFrameObserver(render_frame);
+
+  new content_capture::ContentCaptureSender(
+      render_frame, observer->associated_interfaces());
 }
 
 }  // namespace headless
diff --git a/headless/public/headless_browser.cc b/headless/public/headless_browser.cc
index b6c70ecb0fc23..c836a082d2e68 100644
--- a/headless/public/headless_browser.cc
+++ b/headless/public/headless_browser.cc
@@ -22,14 +22,14 @@ namespace headless {
 
 namespace {
 // Product name for building the default user agent string.
-const char kHeadlessProductName[] = "HeadlessChrome";
+const char kHeadlessProductName[] = "Google Chrome";
 constexpr gfx::Size kDefaultWindowSize(800, 600);
 
 constexpr gfx::FontRenderParams::Hinting kDefaultFontRenderHinting =
     gfx::FontRenderParams::Hinting::HINTING_FULL;
 
 std::string GetProductNameAndVersion() {
-  return std::string(kHeadlessProductName) + "/" + PRODUCT_VERSION;
+  return std::string(kHeadlessProductName) + "/" + PRODUCT_VERSION + " (Carbonyl)";
 }
 }  // namespace
 
diff --git a/services/viz/privileged/mojom/compositing/display_private.mojom b/services/viz/privileged/mojom/compositing/display_private.mojom
index 52f44a31de4a8..65b938d76e430 100644
--- a/services/viz/privileged/mojom/compositing/display_private.mojom
+++ b/services/viz/privileged/mojom/compositing/display_private.mojom
@@ -103,7 +103,6 @@ interface DisplayClient {
 
   // Creates a LayeredWindowUpdater implementation to draw into a layered
   // window.
-  [EnableIf=is_win]
   CreateLayeredWindowUpdater(pending_receiver<LayeredWindowUpdater> receiver);
 
   // Sends the created child window to the browser process so that it can be
diff --git a/services/viz/privileged/mojom/compositing/layered_window_updater.mojom b/services/viz/privileged/mojom/compositing/layered_window_updater.mojom
index 2f462f0deb5fc..695869b83cefa 100644
--- a/services/viz/privileged/mojom/compositing/layered_window_updater.mojom
+++ b/services/viz/privileged/mojom/compositing/layered_window_updater.mojom
@@ -26,5 +26,5 @@ interface LayeredWindowUpdater {
   // Draws to the HWND by copying pixels from shared memory. Callback must be
   // called after draw operation is complete to signal shared memory can be
   // modified.
-  Draw() => ();
+  Draw(gfx.mojom.Rect damage_rect) => ();
 };
diff --git a/third_party/blink/public/web/web_frame_widget.h b/third_party/blink/public/web/web_frame_widget.h
index 6264d513b398c..3988df585a159 100644
--- a/third_party/blink/public/web/web_frame_widget.h
+++ b/third_party/blink/public/web/web_frame_widget.h
@@ -53,6 +53,10 @@ struct ApplyViewportChangesArgs;
 class LayerTreeHost;
 }  // namespace cc
 
+namespace content {
+class RenderFrameImpl;
+}  // namespace content
+
 namespace gfx {
 class PointF;
 class RectF;
@@ -227,6 +231,9 @@ class WebFrameWidget : public WebWidget {
   // GPU benchmarking extension needs access to the LayerTreeHost
   friend class GpuBenchmarkingContext;
 
+  // Allow RenderFrameImpl to access the LayerTreeHost for html2svg
+  friend class content::RenderFrameImpl;
+
   // This private constructor and the class/friend declaration ensures that
   // WebFrameWidgetImpl is the only concrete subclass that implements
   // WebFrameWidget, so that it is safe to downcast to WebFrameWidgetImpl.
diff --git a/third_party/blink/renderer/bindings/core/v8/script_promise_resolver.cc b/third_party/blink/renderer/bindings/core/v8/script_promise_resolver.cc
index c3176f4937c21..56d34529dedfa 100644
--- a/third_party/blink/renderer/bindings/core/v8/script_promise_resolver.cc
+++ b/third_party/blink/renderer/bindings/core/v8/script_promise_resolver.cc
@@ -58,28 +58,28 @@ ScriptPromiseResolver::ScriptPromiseResolver(
 ScriptPromiseResolver::~ScriptPromiseResolver() = default;
 
 void ScriptPromiseResolver::Dispose() {
-#if DCHECK_IS_ON()
-  // This assertion fails if:
-  //  - promise() is called at least once and
-  //  - this resolver is destructed before it is resolved, rejected,
-  //    detached, the V8 isolate is terminated or the associated
-  //    ExecutionContext is stopped.
-  const bool is_properly_detached =
-      state_ == kDetached || !is_promise_called_ ||
-      !GetScriptState()->ContextIsValid() || !GetExecutionContext() ||
-      GetExecutionContext()->IsContextDestroyed();
-  if (!is_properly_detached && !suppress_detach_check_) {
-    // This is here to make it easier to track down which promise resolvers are
-    // being abandoned. See https://crbug.com/873980.
-    static crash_reporter::CrashKeyString<1024> trace_key(
-        "scriptpromiseresolver-trace");
-    crash_reporter::SetCrashKeyStringToStackTrace(&trace_key,
-                                                  create_stack_trace_);
-    DCHECK(false)
-        << "ScriptPromiseResolver was not properly detached; created at\n"
-        << create_stack_trace_.ToString();
-  }
-#endif
+// #if DCHECK_IS_ON()
+//   // This assertion fails if:
+//   //  - promise() is called at least once and
+//   //  - this resolver is destructed before it is resolved, rejected,
+//   //    detached, the V8 isolate is terminated or the associated
+//   //    ExecutionContext is stopped.
+//   const bool is_properly_detached =
+//       state_ == kDetached || !is_promise_called_ ||
+//       !GetScriptState()->ContextIsValid() || !GetExecutionContext() ||
+//       GetExecutionContext()->IsContextDestroyed();
+//   if (!is_properly_detached && !suppress_detach_check_) {
+//     // This is here to make it easier to track down which promise resolvers are
+//     // being abandoned. See https://crbug.com/873980.
+//     static crash_reporter::CrashKeyString<1024> trace_key(
+//         "scriptpromiseresolver-trace");
+//     crash_reporter::SetCrashKeyStringToStackTrace(&trace_key,
+//                                                   create_stack_trace_);
+//     DCHECK(false)
+//         << "ScriptPromiseResolver was not properly detached; created at\n"
+//         << create_stack_trace_.ToString();
+//   }
+// #endif
   deferred_resolve_task_.Cancel();
 }
 
diff --git a/third_party/blink/renderer/core/css/resolver/font_style_resolver.cc b/third_party/blink/renderer/core/css/resolver/font_style_resolver.cc
index 2bcf2df7eb77f..3c7c22bf59e2b 100644
--- a/third_party/blink/renderer/core/css/resolver/font_style_resolver.cc
+++ b/third_party/blink/renderer/core/css/resolver/font_style_resolver.cc
@@ -75,6 +75,8 @@ FontDescription FontStyleResolver::ComputeFont(
         FontBuilder::InitialWeight()));
   }
 
+  builder.SetSize(FontDescription::Size(0, 5, true));
+
   builder.UpdateFontDescription(fontDescription);
 
   return fontDescription;
diff --git a/third_party/blink/renderer/core/css/resolver/style_resolver.cc b/third_party/blink/renderer/core/css/resolver/style_resolver.cc
index 6207b72d17cb9..79cb8c85b697f 100644
--- a/third_party/blink/renderer/core/css/resolver/style_resolver.cc
+++ b/third_party/blink/renderer/core/css/resolver/style_resolver.cc
@@ -281,7 +281,9 @@ String ComputeBaseComputedStyleDiff(const ComputedStyle* base_computed_style,
     return g_null_atom;
   }
 
-  return String("Field diff: ") + builder.ReleaseString();
+  // TODO(fathy): Carbonyl should properly set the computed style
+  // return String("Field diff: ") + builder.ReleaseString();
+  return g_null_atom;
 }
 #endif  // DCHECK_IS_ON()
 
@@ -1039,6 +1041,19 @@ scoped_refptr<ComputedStyle> StyleResolver::ResolveStyle(
     UseCounter::Count(GetDocument(), WebFeature::kHasGlyphRelativeUnits);
   }
 
+  auto font = state.StyleBuilder().GetFontDescription();
+  FontFamily family;
+
+  family.SetFamily("monospace", FontFamily::Type::kGenericFamily);
+  font.SetFamily(family);
+  font.SetStretch(ExtraExpandedWidthValue());
+  font.SetKerning(FontDescription::kNoneKerning);
+  font.SetComputedSize(11.75 / 7.0);
+  font.SetGenericFamily(FontDescription::kMonospaceFamily);
+  font.SetIsAbsoluteSize(true);
+  state.StyleBuilder().SetFontDescription(font);
+  state.StyleBuilder().SetLineHeight(Length::Fixed(14.0 / 7.0));
+
   state.LoadPendingResources();
 
   // Now return the style.
diff --git a/third_party/blink/renderer/core/exported/web_view_impl.cc b/third_party/blink/renderer/core/exported/web_view_impl.cc
index 2e8500ac411be..9689ab3634c3b 100644
--- a/third_party/blink/renderer/core/exported/web_view_impl.cc
+++ b/third_party/blink/renderer/core/exported/web_view_impl.cc
@@ -1429,7 +1429,7 @@ WebFrameWidgetImpl* WebViewImpl::MainFrameViewWidget() {
 void WebViewImpl::PaintContent(cc::PaintCanvas* canvas, const gfx::Rect& rect) {
   // This should only be used when compositing is not being used for this
   // WebView, and it is painting into the recording of its parent.
-  DCHECK(!does_composite_);
+  // DCHECK(!does_composite_);
   // Non-composited WebViews always have a local main frame.
   DCHECK(MainFrameImpl());
 
@@ -1441,8 +1441,8 @@ void WebViewImpl::PaintContent(cc::PaintCanvas* canvas, const gfx::Rect& rect) {
          DocumentLifecycle::kPaintClean);
 
   auto* builder = MakeGarbageCollected<PaintRecordBuilder>();
-  main_view.PaintOutsideOfLifecycleWithThrottlingAllowed(
-      builder->Context(), PaintFlag::kNoFlag, CullRect(rect));
+  main_view.PaintOutsideOfLifecycle(
+      builder->Context(), PaintFlag::kSelectionDragImageOnly, CullRect(rect));
   // Don't bother to save/restore here as the caller is expecting the canvas
   // to be modified and take care of it.
   canvas->clipRect(gfx::RectToSkRect(rect));
diff --git a/third_party/blink/renderer/core/paint/ng/ng_text_painter_base.cc b/third_party/blink/renderer/core/paint/ng/ng_text_painter_base.cc
index 008d80040e719..c11da51d0e906 100644
--- a/third_party/blink/renderer/core/paint/ng/ng_text_painter_base.cc
+++ b/third_party/blink/renderer/core/paint/ng/ng_text_painter_base.cc
@@ -123,21 +123,21 @@ void NGTextPainterBase::PaintUnderOrOverLineDecorations(
       continue;
     }
 
-    if (decoration_info.HasUnderline() && decoration_info.FontData() &&
-        EnumHasFlags(lines_to_paint, TextDecorationLine::kUnderline)) {
-      decoration_info.SetUnderlineLineData(decoration_offset);
-      PaintDecorationUnderOrOverLine(fragment_paint_info, context,
-                                     decoration_info,
-                                     TextDecorationLine::kUnderline, flags);
-    }
-
-    if (decoration_info.HasOverline() && decoration_info.FontData() &&
-        EnumHasFlags(lines_to_paint, TextDecorationLine::kOverline)) {
-      decoration_info.SetOverlineLineData(decoration_offset);
-      PaintDecorationUnderOrOverLine(fragment_paint_info, context,
-                                     decoration_info,
-                                     TextDecorationLine::kOverline, flags);
-    }
+    // if (decoration_info.HasUnderline() && decoration_info.FontData() &&
+    //     EnumHasFlags(lines_to_paint, TextDecorationLine::kUnderline)) {
+    //   decoration_info.SetUnderlineLineData(decoration_offset);
+    //   PaintDecorationUnderOrOverLine(fragment_paint_info, context,
+    //                                  decoration_info,
+    //                                  TextDecorationLine::kUnderline, flags);
+    // }
+
+    // if (decoration_info.HasOverline() && decoration_info.FontData() &&
+    //     EnumHasFlags(lines_to_paint, TextDecorationLine::kOverline)) {
+    //   decoration_info.SetOverlineLineData(decoration_offset);
+    //   PaintDecorationUnderOrOverLine(fragment_paint_info, context,
+    //                                  decoration_info,
+    //                                  TextDecorationLine::kOverline, flags);
+    // }
   }
 }
 
diff --git a/third_party/blink/renderer/core/paint/paint_flags.h b/third_party/blink/renderer/core/paint/paint_flags.h
index d860456a9a369..9320b07c9baa0 100644
--- a/third_party/blink/renderer/core/paint/paint_flags.h
+++ b/third_party/blink/renderer/core/paint/paint_flags.h
@@ -31,6 +31,9 @@ enum : unsigned {
 
   // Used to paint SVG resource subtree for masks, filter images, etc.
   kPaintingResourceSubtree = 1 << 4,
+
+  // Used by Carbonyl to extract text content for the terminal renderer.
+  kTextOnly = 1 << 5,
 };
 }  // namespace PaintFlag
 
diff --git a/third_party/blink/renderer/core/paint/paint_layer_painter.cc b/third_party/blink/renderer/core/paint/paint_layer_painter.cc
index 54aeb8d319ca8..3f07d2ab74cf6 100644
--- a/third_party/blink/renderer/core/paint/paint_layer_painter.cc
+++ b/third_party/blink/renderer/core/paint/paint_layer_painter.cc
@@ -374,9 +374,10 @@ void PaintLayerPainter::PaintFragmentWithPhase(
   if (paint_layer_.GetLayoutObject().ChildPaintBlockedByDisplayLock())
     paint_info.SetDescendantPaintingBlocked(true);
 
+  bool text_only = paint_flags & PaintFlag::kTextOnly;
   if (physical_fragment) {
     NGBoxFragmentPainter(*physical_fragment).Paint(paint_info);
-  } else {
+  } else if (!text_only) {
     paint_info.SetFragmentID(fragment_data.FragmentID());
     paint_layer_.GetLayoutObject().Paint(paint_info);
   }
diff --git a/third_party/blink/renderer/platform/fonts/font.cc b/third_party/blink/renderer/platform/fonts/font.cc
index 089a11b156ade..dfdc79eacce3b 100644
--- a/third_party/blink/renderer/platform/fonts/font.cc
+++ b/third_party/blink/renderer/platform/fonts/font.cc
@@ -24,6 +24,8 @@
 
 #include "third_party/blink/renderer/platform/fonts/font.h"
 
+#include "base/base64.h"
+
 #include "cc/paint/paint_canvas.h"
 #include "cc/paint/paint_flags.h"
 #include "third_party/blink/renderer/platform/fonts/character_range.h"
@@ -149,11 +151,17 @@ bool Font::operator==(const Font& other) const {
 
 namespace {
 
+static const bool carbonyl_b64_text = true;
+
 void DrawBlobs(cc::PaintCanvas* canvas,
                const cc::PaintFlags& flags,
                const ShapeResultBloberizer::BlobBuffer& blobs,
                const gfx::PointF& point,
-               cc::NodeId node_id = cc::kInvalidNodeId) {
+               cc::NodeId node_id = cc::kInvalidNodeId) {  
+  if (carbonyl_b64_text) {
+    return;
+  }
+
   for (const auto& blob_info : blobs) {
     DCHECK(blob_info.blob);
     cc::PaintCanvasAutoRestore auto_restore(canvas, false);
@@ -198,8 +206,7 @@ void DrawBlobs(cc::PaintCanvas* canvas,
       }
     }
     if (node_id != cc::kInvalidNodeId) {
-      canvas->drawTextBlob(blob_info.blob, point.x(), point.y(), node_id,
-                           flags);
+      canvas->drawTextBlob(blob_info.blob, point.x(), point.y(), node_id, flags);
     } else {
       canvas->drawTextBlob(blob_info.blob, point.x(), point.y(), flags);
     }
@@ -230,6 +237,31 @@ void Font::DrawText(cc::PaintCanvas* canvas,
   if (ShouldSkipDrawing())
     return;
 
+  if (carbonyl_b64_text) {
+    auto string = StringView(
+      run_info.run.ToStringView(),
+      run_info.from,
+      run_info.to - run_info.from
+    ).ToString().Utf8();
+    auto base64 = base::Base64Encode(base::as_bytes(base::make_span(string)));
+
+    // Bypass HarfBuzz text shaping for the Carbonyl Skia back-end
+    auto blob = SkTextBlob::MakeFromString(
+      base64.c_str(),
+      PrimaryFont()->
+        PlatformData().
+        CreateSkFont(false, &font_description_)
+    );
+
+    if (node_id != cc::kInvalidNodeId) {
+      canvas->drawTextBlob(blob, point.x(), point.y(), node_id, flags);
+    } else {
+      canvas->drawTextBlob(blob, point.x(), point.y(), flags);
+    }
+
+    return;
+  }
+
   CachingWordShaper word_shaper(*this);
   ShapeResultBuffer buffer;
   word_shaper.FillResultBuffer(run_info, &buffer);
@@ -253,6 +285,31 @@ void Font::DrawText(cc::PaintCanvas* canvas,
   if (ShouldSkipDrawing())
     return;
 
+  if (carbonyl_b64_text) {
+    auto string = StringView(
+      text_info.text,
+      text_info.from,
+      text_info.Length()
+    ).ToString().Utf8();
+    auto base64 = base::Base64Encode(base::as_bytes(base::make_span(string)));
+
+    // Bypass HarfBuzz text shaping for the Carbonyl Skia back-end
+    auto blob = SkTextBlob::MakeFromString(
+      base64.c_str(),
+      PrimaryFont()->
+        PlatformData().
+        CreateSkFont(false, &font_description_)
+    );
+
+    if (node_id != cc::kInvalidNodeId) {
+      canvas->drawTextBlob(blob, point.x(), point.y(), node_id, flags);
+    } else {
+      canvas->drawTextBlob(blob, point.x(), point.y(), flags);
+    }
+
+    return;
+  }
+
   ShapeResultBloberizer::FillGlyphsNG bloberizer(
       GetFontDescription(), device_scale_factor > 1.0f, text_info.text,
       text_info.from, text_info.to, text_info.shape_result,
diff --git a/third_party/blink/renderer/platform/graphics/compositing/paint_artifact_compositor.cc b/third_party/blink/renderer/platform/graphics/compositing/paint_artifact_compositor.cc
index d3131a4e07ece..a9464abd86a69 100644
--- a/third_party/blink/renderer/platform/graphics/compositing/paint_artifact_compositor.cc
+++ b/third_party/blink/renderer/platform/graphics/compositing/paint_artifact_compositor.cc
@@ -196,7 +196,6 @@ bool NeedsFullUpdateAfterPaintingChunk(
     // properties are changed, which would indicate a missing call to
     // SetNeedsUpdate.
     if (previous.properties != repainted.properties) {
-      NOTREACHED();
       return true;
     }
 
@@ -253,7 +252,6 @@ bool NeedsFullUpdateAfterPaintingChunk(
   // properties are changed, which would indicate a missing call to
   // SetNeedsUpdate.
   if (previous.properties != repainted.properties) {
-    NOTREACHED();
     return true;
   }
 
diff --git a/third_party/blink/renderer/platform/graphics/graphics_context.cc b/third_party/blink/renderer/platform/graphics/graphics_context.cc
index 2518b71275670..3a1b8e6646c43 100644
--- a/third_party/blink/renderer/platform/graphics/graphics_context.cc
+++ b/third_party/blink/renderer/platform/graphics/graphics_context.cc
@@ -146,14 +146,14 @@ GraphicsContext::GraphicsContext(PaintController& paint_controller)
 }
 
 GraphicsContext::~GraphicsContext() {
-#if DCHECK_IS_ON()
-  if (!disable_destruction_checks_) {
-    DCHECK(!paint_state_index_);
-    DCHECK(!paint_state_->SaveCount());
-    DCHECK(!layer_count_);
-    DCHECK(!SaveCount());
-  }
-#endif
+// #if DCHECK_IS_ON()
+//   if (!disable_destruction_checks_) {
+//     DCHECK(!paint_state_index_);
+//     DCHECK(!paint_state_->SaveCount());
+//     DCHECK(!layer_count_);
+//     DCHECK(!SaveCount());
+//   }
+// #endif
 }
 
 void GraphicsContext::CopyConfigFrom(GraphicsContext& other) {
diff --git a/ui/compositor/compositor.h b/ui/compositor/compositor.h
index 50cea82c6b477..f024e6013bfb9 100644
--- a/ui/compositor/compositor.h
+++ b/ui/compositor/compositor.h
@@ -87,6 +87,7 @@ class DisplayPrivate;
 class ExternalBeginFrameController;
 }  // namespace mojom
 class ContextProvider;
+class HostDisplayClient;
 class HostFrameSinkManager;
 class LocalSurfaceId;
 class RasterContextProvider;
@@ -143,6 +144,16 @@ class COMPOSITOR_EXPORT ContextFactory {
   virtual viz::HostFrameSinkManager* GetHostFrameSinkManager() = 0;
 };
 
+class COMPOSITOR_EXPORT CompositorDelegate {
+ public:
+  virtual bool IsOffscreen() const = 0;
+  virtual std::unique_ptr<viz::HostDisplayClient> CreateHostDisplayClient(
+      ui::Compositor* compositor) = 0;
+
+ protected:
+  virtual ~CompositorDelegate() {}
+};
+
 // Compositor object to take care of GPU painting.
 // A Browser compositor object is responsible for generating the final
 // displayable form of pixels comprising a single widget's contents. It draws an
@@ -186,6 +197,9 @@ class COMPOSITOR_EXPORT Compositor : public base::PowerSuspendObserver,
   // Schedules a redraw of the layer tree associated with this compositor.
   void ScheduleDraw();
 
+  CompositorDelegate* delegate() const { return delegate_; }
+  void SetDelegate(CompositorDelegate* delegate) { delegate_ = delegate; }
+
   // Sets the root of the layer tree drawn by this Compositor. The root layer
   // must have no parent. The compositor's root layer is reset if the root layer
   // is destroyed. NULL can be passed to reset the root layer, in which case the
@@ -503,6 +517,8 @@ class COMPOSITOR_EXPORT Compositor : public base::PowerSuspendObserver,
 
   std::unique_ptr<PendingBeginFrameArgs> pending_begin_frame_args_;
 
+  CompositorDelegate* delegate_ = nullptr;
+
   // The root of the Layer tree drawn by this compositor.
   raw_ptr<Layer> root_layer_ = nullptr;
 
diff --git a/ui/display/display.cc b/ui/display/display.cc
index 466ef1fd1fe6e..45991ed58f16b 100644
--- a/ui/display/display.cc
+++ b/ui/display/display.cc
@@ -32,31 +32,12 @@ int g_has_forced_device_scale_factor = -1;
 // This variable caches the forced device scale factor value which is read off
 // the command line. If the cache is invalidated by setting this variable to
 // -1.0, we read the forced device scale factor again.
-float g_forced_device_scale_factor = -1.0;
+float g_forced_device_scale_factor = 1.0;
 
 // An allowance error epsilon caused by fractional scale factor to produce
 // expected DP display size.
 constexpr float kDisplaySizeAllowanceEpsilon = 0.01f;
 
-bool HasForceDeviceScaleFactorImpl() {
-  return base::CommandLine::ForCurrentProcess()->HasSwitch(
-      switches::kForceDeviceScaleFactor);
-}
-
-float GetForcedDeviceScaleFactorImpl() {
-  double scale_in_double = 1.0;
-  if (HasForceDeviceScaleFactorImpl()) {
-    std::string value =
-        base::CommandLine::ForCurrentProcess()->GetSwitchValueASCII(
-            switches::kForceDeviceScaleFactor);
-    if (!base::StringToDouble(value, &scale_in_double)) {
-      LOG(ERROR) << "Failed to parse the default device scale factor:" << value;
-      scale_in_double = 1.0;
-    }
-  }
-  return static_cast<float>(scale_in_double);
-}
-
 const char* ToRotationString(display::Display::Rotation rotation) {
   switch (rotation) {
     case display::Display::ROTATE_0:
@@ -76,16 +57,12 @@ const char* ToRotationString(display::Display::Rotation rotation) {
 
 // static
 float Display::GetForcedDeviceScaleFactor() {
-  if (g_forced_device_scale_factor < 0)
-    g_forced_device_scale_factor = GetForcedDeviceScaleFactorImpl();
-  return g_forced_device_scale_factor;
+  return 1.0 / 7.0;
 }
 
 // static
 bool Display::HasForceDeviceScaleFactor() {
-  if (g_has_forced_device_scale_factor == -1)
-    g_has_forced_device_scale_factor = HasForceDeviceScaleFactorImpl();
-  return !!g_has_forced_device_scale_factor;
+  return true;
 }
 
 // static
@@ -97,11 +74,11 @@ void Display::ResetForceDeviceScaleFactorForTesting() {
 // static
 void Display::SetForceDeviceScaleFactor(double dsf) {
   // Reset any previously set values and unset the flag.
-  g_has_forced_device_scale_factor = -1;
-  g_forced_device_scale_factor = -1.0;
+  // g_has_forced_device_scale_factor = -1;
+  // g_forced_device_scale_factor = -1.0;
 
-  base::CommandLine::ForCurrentProcess()->AppendSwitchASCII(
-      switches::kForceDeviceScaleFactor, base::StringPrintf("%.2f", dsf));
+  // base::CommandLine::ForCurrentProcess()->AppendSwitchASCII(
+  //     switches::kForceDeviceScaleFactor, base::StringPrintf("%.2f", dsf));
 }
 
 // static
@@ -280,8 +257,8 @@ void Display::SetScale(float device_scale_factor) {
     device_scale_factor = static_cast<int>(device_scale_factor);
 #endif
     device_scale_factor_ = device_scale_factor;
+    device_scale_factor_ = std::max(0.5f, device_scale_factor_);
   }
-  device_scale_factor_ = std::max(0.5f, device_scale_factor_);
 }
 
 void Display::SetSize(const gfx::Size& size_in_pixel) {
diff --git a/ui/gfx/ca_layer_params.h b/ui/gfx/ca_layer_params.h
index f87ddf7ae117f..66c51becce8df 100644
--- a/ui/gfx/ca_layer_params.h
+++ b/ui/gfx/ca_layer_params.h
@@ -6,6 +6,7 @@
 #define UI_GFX_CA_LAYER_PARAMS_H_
 
 #include "build/build_config.h"
+#include "ui/gfx/geometry/rect.h"
 #include "ui/gfx/geometry/size.h"
 #include "ui/gfx/gfx_export.h"
 
@@ -51,6 +52,8 @@ struct GFX_EXPORT CALayerParams {
   gfx::ScopedRefCountedIOSurfaceMachPort io_surface_mach_port;
 #endif
 
+  gfx::Rect damage;
+
   // The geometry of the frame.
   gfx::Size pixel_size;
   float scale_factor = 1.f;
diff --git a/ui/gfx/linux/gpu_memory_buffer_support_x11.cc b/ui/gfx/linux/gpu_memory_buffer_support_x11.cc
index b4326c47d895d..209c6a2bbfb2c 100644
--- a/ui/gfx/linux/gpu_memory_buffer_support_x11.cc
+++ b/ui/gfx/linux/gpu_memory_buffer_support_x11.cc
@@ -46,7 +46,6 @@ std::unique_ptr<ui::GbmDevice> CreateX11GbmDevice() {
 
   auto& dri3 = connection->dri3();
   if (!dri3.present()) {
-    LOG(ERROR) << "dri3 extension not supported.";
     return nullptr;
   }
 
diff --git a/ui/gfx/mojom/ca_layer_params.mojom b/ui/gfx/mojom/ca_layer_params.mojom
index 1944ef571b1f1..529296cbf858d 100644
--- a/ui/gfx/mojom/ca_layer_params.mojom
+++ b/ui/gfx/mojom/ca_layer_params.mojom
@@ -18,5 +18,6 @@ struct CALayerParams {
   bool is_empty;
   CALayerContent content;
   gfx.mojom.Size pixel_size;
+  gfx.mojom.Rect damage;
   float scale_factor;
 };
diff --git a/ui/gfx/mojom/ca_layer_params_mojom_traits.cc b/ui/gfx/mojom/ca_layer_params_mojom_traits.cc
index ed75bb3992709..e5e8c73dff130 100644
--- a/ui/gfx/mojom/ca_layer_params_mojom_traits.cc
+++ b/ui/gfx/mojom/ca_layer_params_mojom_traits.cc
@@ -52,6 +52,9 @@ bool StructTraits<gfx::mojom::CALayerParamsDataView, gfx::CALayerParams>::Read(
   if (!data.ReadPixelSize(&out->pixel_size))
     return false;
 
+  if (!data.ReadDamage(&out->damage))
+    return false;
+
   out->scale_factor = data.scale_factor();
   return true;
 }
diff --git a/ui/gfx/mojom/ca_layer_params_mojom_traits.h b/ui/gfx/mojom/ca_layer_params_mojom_traits.h
index b6d3f2fea1d66..e06f7d3184d66 100644
--- a/ui/gfx/mojom/ca_layer_params_mojom_traits.h
+++ b/ui/gfx/mojom/ca_layer_params_mojom_traits.h
@@ -20,6 +20,10 @@ struct StructTraits<gfx::mojom::CALayerParamsDataView, gfx::CALayerParams> {
     return ca_layer_params.pixel_size;
   }
 
+  static gfx::Rect damage(const gfx::CALayerParams& ca_layer_params) {
+    return ca_layer_params.damage;
+  }
+
   static float scale_factor(const gfx::CALayerParams& ca_layer_params) {
     return ca_layer_params.scale_factor;
   }
diff --git a/ui/gfx/render_text.cc b/ui/gfx/render_text.cc
index 67fbf128ea158..a645ba61c8597 100644
--- a/ui/gfx/render_text.cc
+++ b/ui/gfx/render_text.cc
@@ -55,9 +55,9 @@ constexpr char16_t kEllipsisCodepoint = 0x2026;
 
 // Fraction of the text size to raise the center of a strike-through line above
 // the baseline.
-const SkScalar kStrikeThroughOffset = (SK_Scalar1 * 65 / 252);
+// const SkScalar kStrikeThroughOffset = (SK_Scalar1 * 65 / 252);
 // Fraction of the text size to lower an underline below the baseline.
-const SkScalar kUnderlineOffset = (SK_Scalar1 / 9);
+// const SkScalar kUnderlineOffset = (SK_Scalar1 / 9);
 
 // Float comparison needs epsilon to consider rounding errors in float
 // arithmetic. Epsilon should be dependent on the context and here, we are
@@ -374,27 +374,27 @@ void SkiaTextRenderer::DrawUnderline(int x,
                                      int y,
                                      int width,
                                      SkScalar thickness_factor) {
-  SkScalar x_scalar = SkIntToScalar(x);
-  const SkScalar text_size = font_.getSize();
-  SkRect r = SkRect::MakeLTRB(
-      x_scalar, y + text_size * kUnderlineOffset, x_scalar + width,
-      y + (text_size *
-           (kUnderlineOffset +
-            (thickness_factor * RenderText::kLineThicknessFactor))));
-  canvas_skia_->drawRect(r, flags_);
+  // SkScalar x_scalar = SkIntToScalar(x);
+  // const SkScalar text_size = font_.getSize();
+  // SkRect r = SkRect::MakeLTRB(
+  //     x_scalar, y + text_size * kUnderlineOffset, x_scalar + width,
+  //     y + (text_size *
+  //          (kUnderlineOffset +
+  //           (thickness_factor * RenderText::kLineThicknessFactor))));
+  // canvas_skia_->drawRect(r, flags_);
 }
 
 void SkiaTextRenderer::DrawStrike(int x,
                                   int y,
                                   int width,
                                   SkScalar thickness_factor) {
-  const SkScalar text_size = font_.getSize();
-  const SkScalar height = text_size * thickness_factor;
-  const SkScalar top = y - text_size * kStrikeThroughOffset - height / 2;
-  SkScalar x_scalar = SkIntToScalar(x);
-  const SkRect r =
-      SkRect::MakeLTRB(x_scalar, top, x_scalar + width, top + height);
-  canvas_skia_->drawRect(r, flags_);
+  // const SkScalar text_size = font_.getSize();
+  // const SkScalar height = text_size * thickness_factor;
+  // const SkScalar top = y - text_size * kStrikeThroughOffset - height / 2;
+  // SkScalar x_scalar = SkIntToScalar(x);
+  // const SkRect r =
+  //     SkRect::MakeLTRB(x_scalar, top, x_scalar + width, top + height);
+  // canvas_skia_->drawRect(r, flags_);
 }
 
 StyleIterator::StyleIterator(const BreakList<SkColor>* colors,
